##############################################
#Applied Spatial Statistics and Econometrics: Data Analysis in R (Routledge, 2020) 
#Przestrzenne metody ilościowe w R: statystyka, ekonometria, uczenie maszynowe, analiza danych (CeDeWu, 2020)
#Editor: Katarzyna Kopczewska 
#Authors: Katarzyna Kopczewska, Maria Kubara, Piotr Ćwiakowski, Mateusz Kopyt, Piotr Wójcik, Alessandro Festi, Kateryna Zabarina
#This book is a part of project supported by the Polish National Science Center (NCN) on „Spatial econometric models with fixed and changing neighborhood structure. Application for real estate valuation and business location” (OPUS 12, contract no. UMO-2016/23/B/ HS4/02363).
#All sample data used in the book and the codes presented in the content of the book were placed on https://github.com/kkopczewska/spatial_book 
##############################################

#Chapter 8
#Spatial point pattern analysis and spatial interpolation
#Kateryna Zabarina, orcid.org/0000-0003-0241-6977

#8.1. Introduction and main definitions
#8.1.1. Dataset

firms<-read.csv("geoloc_data_firms.csv", header=TRUE, dec=",", sep=";")
names(firms)

# size of employment – variable GR_EMPL
# GR_EMPL = 1 -> between 1 and 9 persons
# GR_EMPL = 2 -> between 10 and 49 persons
# GR_EMPL = 3 -> between 50 and 249 persons
# GR_EMPL = 4 -> between 250 and 999 persons
# GR_EMPL = 5 -> more than 1500 persons

table(firms$GR_EMPL)
firms$empl<-ifelse(firms$GR_EMPL==1, 5, ifelse(firms$GR_EMPL==2, 30, ifelse(firms$GR_EMPL==3,150, ifelse(firms$GR_EMPL==4, 600, 1500))))
table(firms$empl)
table(firms$LEGAL_FORM1)

#8.1.2. Creation of window and point pattern

# load packages
library(sp)       # for spTransform()
library(spatstat) # for as.owin() 
library(rgdal)    # for readOGR()
library(maptools) # necessary to run as.owin()

voi<-readOGR(".", "wojewodztwa") # read data 
region<-voi[voi$jpt_nazwa_=="lubelskie",] # still sp class
region<-spTransform(region, CRS("+proj=merc +datum=WGS84")) # planar coords

W<-as.owin(region) # conversion to owin class object
W<-as(region, "owin") # conversion to owin class object

class(W)
library(spatstat)

# change of projection of points
cord<-as.matrix(cbind(firms$coords.x1, firms$coords.x2))
cord.sp<-SpatialPoints(cord) # points in sp class - spherical
proj4string(cord.sp)<-CRS("+proj=longlat +datum=NAD83") # spherical
cord.sp<-spTransform(cord.sp, CRS("+proj=merc +datum=NAD83")) #planar

# unmarked point pattern
ppp_um<-ppp(x=cord.sp@coords[,1], y=cord.sp@coords[,2], window=W)

# marked point pattern
ppp_m<-ppp(x=cord.sp@coords[,1], y=cord.sp@coords[,2], window=W, marks=firms$GR_LPRAC)

# plotting unmarked point pattern from example above
par(mar=c(1,1,1,1))
plot(ppp_um, main= "Study point pattern, 37087 obs.") # with spatstat::

# creating a circle 
# center of the circle approximately in the center of region
# a and b – ellipse radia, centre – center of circle, 
# phi – anticlockwise rotation angle
circ<-ellipse(a=200000, b=200000, centre=c(2547063.75417, 6635810.07789), phi=pi)
X.c<-ppp(x=cord.sp@coords[,1], y=cord.sp@coords[,2], window=circ)
plot(X.c) # plotting 

# creating a square
# in first bracket - x coordinate of bottom left and top right vertices
# in second bracket – the same for y coordinates
boundingbox(W) # getting coordinates of boudnding box
# window: rectangle = [2406231.2, 2687896.3] x [6457131, 6818514] units
sq<-owin(c(2406232, 2687897), c(6457131 ,6818514)) # create a rectangle
X.sq<-ppp(x=cord.sp@coords[,1], y=cord.sp@coords[,2], window=sq)
plot(X.sq) #plotting

#8.1.3. Marks

# numerical marks
ppp_empl<-ppp(x=cord.sp@coords[,1], y=cord.sp@coords[,2], window=W, marks=firms$empl) # marks representing employment level

# categorical marks
ppp_firms<-ppp(x=cord.sp@coords[,1], y=cord.sp@coords[,2], window=W, marks=as.factor(firms$LEGAL_FORM1)) # marks representing legal form

# marked point pattern with numerical marks – ppp_empl
# control for shape of points according to number of employees
# option markscale is a multiplier for all mark values 
plot(ppp_empl, markscale=0.002, pch=1)

# marked point pattern with categorical marks – ppp_firms
# control for colors of points according to legal form
plot(ppp_firms, pch=1, cex=0.8, cols= c("red", "green", "blue"))

# pattern contains 37087 points, 
# some mark values cannot be displayed correctly with plot() function
# numerical values will be converted to class ‘factor’, 
# pattern will be splitted and then plotted layer by layer

marks(ppp_empl)<-as.factor(marks(ppp_empl))
split_ppp_empl<-split(ppp_empl)

# window of plot
plot(W, main="Marked point pattern \n representing number of employees")
# consecutive layers of point pattern 
# first layer – with the most observed value
plot(split_ppp_empl[[1]], add=TRUE, cex=0.75, pch=16, col="green")
plot(split_ppp_empl[[2]], add=TRUE, cex=1, pch=16, col="blue")
plot(split_ppp_empl[[3]], add=TRUE, cex=1.25, pch=16, col="red")
plot(split_ppp_empl[[4]], add=TRUE, cex=1.5, pch=16, col="black")
plot(split_ppp_empl[[5]], add=TRUE, cex=1.75, pch=16, col="orange")
legend("bottomleft", legend=c("5","30","150","600","1500"),
       col=c("green", "blue", "red", "black", "orange"), pch=16, cex=0.8)

# split
split_ppp_firms<-split(ppp_firms, reduce=TRUE) 
cols <- c("red", "green", "blue")
# step by step 
plot(W, main="Marked point pattern \n representing legal form")
plot(split_ppp_firms[[2]], add=TRUE, col=cols[2], pch=18)
plot(split_ppp_firms[[3]], add=TRUE, col=cols[3], pch=18)
plot(split_ppp_firms[[1]], add=TRUE, col=cols[1], pch=18)
legend("bottomleft", legend=c("natural person", "organizational entity \n without legal \n personality", "legal person"),
       col=c("green", "blue", "red"), pch=18, cex=0.8)

firms$sector[firms$SEC_PKD7=="A"] <- "agriculture"
firms$sector[firms$SEC_PKD7=="F"] <- "construction"
firms$sector[firms$SEC_PKD7 %in% c("B" , "C" , "D" , "E")] <- "production"
firms$sector[firms$SEC_PKD7 %in% c("G","H","I","J","K","L","M","N","O","Q","P","R","S")] <- "service"

summary(marks(ppp_firms)) # old mark values 
marks(ppp_firms)<-as.factor(firms$sector) # change values 
summary(marks(ppp_firms)) # new mark values
plot(ppp_firms, cols=c("red", "blue", "green", "black"), pch=1, cex=0.75)

## using setmarks()
summary(setmarks(ppp_firms, as.factor(firms$sector))) 
summary(marks(ppp_firms)) # no changes can be observed
## alternative - using pipeline operator from package magrittr::
library(magrittr)
ppp_empl %mark% as.factor(firms$sector)

unmark(ppp_firms)
ppp_firms

# or equivalently
marks(ppp_firms) <- NULL
ppp_firms

marks(ppp_firms) <- as.factor(firms$SEC_PKD7)
summary(marks(ppp_firms))

#8.1.4. Covariates

# load libraries
library(rgdal) 	# reading shapefiles
library(sp)    	# for spDistsN1()
library(spatstat) # for window, pixel image

# specify coordinates for Lublin
# first value x/longitude, second value y/latitude
lublin<-c(22.568445, 51.246452) # in case of spherical

# create vector of distances
# object ‘firms’ should be of class SpatialPointsDataFrame 
# so it should be transformed as follows:
coordinates(firms)<-~coords.x1+coords.x2

# calculation of distances, option longlat=TRUE gives results in km
firms$dist<-spDistsN1(firms, lublin, longlat=TRUE)

# creation of a matrix
mat_im<-cbind(firms@coords[,1], firms@coords[,2], firms$dist)

mat_pix <- as.im(mat_im, W)
plot(mat_pix) # Fig.8.3b

#8.1.5. Duplicated points

sum(duplicated(ppp_um))
ppp_um <- unique(ppp_um)
ppp_um
summary(duplicated(ppp_um))

## alternative way
ppp_um<-ppp_um[!duplicated(ppp_um)] # result is the same as above

d2 <- summary(duplicated(ppp_firms))
d2

xr1 <- rjitter(ppp_um, 0.02)
summary(duplicated(xr1))
plot(xr1)

xr2 <- rjitter(ppp_firms, 0.02)
summary(duplicated(xr2))
#8.1.6. Projection and rescaling

area.owin(W)
summary(ppp_um)
ppp_um<-rescale(ppp_um, 1593,52, "km")
summary(ppp_um)

library(sp) 
library(rgdal)

# check for CRS of voivodeship borders
voi<-readOGR(".", "wojewodztwa") # 16 units 
proj4string(voi)
#[1] "+proj=tmerc +lat_0=0 +lon_0=19 +k=0.9993 +x_0=500000 +y_0=-5300000 #+ellps=GRS80 +units=m +no_defs"

# first transform to sp object
coordinates(firms)<-~coords.x1+coords.x2
proj4string(firms)<-CRS("+proj=tmerc +lat_0=0 +lon_0=19 +k=0.9993 +x_0=500000 +y_0=-5300000 +ellps=GRS80 +units=m +no_defs")

summary(firms)

# choose proper voivodeship
region<-voi[voi$jpt_nazwa_=="lubelskie",]

ids<-sample(dim(firms)[1], size=1500)
firms.sub<-firms[ids,]

# check whether CRS are the same for region and SpatialPoints of firms
proj4string(region)
#[1] "+proj=tmerc +lat_0=0 +lon_0=19 +k=0.9993 +x_0=500000 +y_0=-5300000 #+ellps=GRS80 +units=m +no_defs"

# convert to class ‘owin’
W<-as(region, "owin")
p<-ppp(firms.sub$coords.x1, firms.sub$coords.x2, W)
# Warning message:
# 1500 points were rejected as lying outside the specified window 

summary(p)

proj4string(firms)
proj4string(region)

bbox(firms)
bbox(region)

# unmarked
ppp_um<-unique(ppp_um)
ppp_um<-rescale(ppp_um, 1593.52, "km")
set.seed(ppp_um$n) # to guarantee the same data in new drawing
s1<-(runif(ppp_um$n)<0.06)
um_s<-ppp_um[s1]
summary(duplicated(um_s)) # 1502 points, no duplicates found

# marked, marks are industry sectors
ppp_firms<-rjitter(ppp_firms, 0.02)
ppp_firms<-rescale(ppp_firms, 1593.52, "km")
set.seed(ppp_firms$n)
s2<-(runif(ppp_firms$n)<0.045)
mm_s<-ppp_firms[s2]
summary(duplicated(mm_s)) #1589 points, with no duplicates found

#8.2. Intensity-based analysis of unmarked point pattern

homo_model<-ppm(pattern, ~1)
inhom_model_1<-ppm(pattern, ~x)
inhom_model_2<-ppm(pattern, ~covariate)

#8.2.1. Quadrat test

q1<-quadrat.test(um_s, nx=5, ny=5)
q1
names(q1)
q1$method

q2<-quadrat.test(um_s, nx=10, ny=10)
q2$p.value

q3<-quadrat.test(um_s, nx=25, ny=25)
q3$p.value

q4<-quadrat.test(um_s, nx=50, ny=50)
q4$p.value

q5<-quadrat.test(um_s, nx=100, ny=100)
q5$p.value 

#8.2.2. Tests with spatial covariates

ks.rand<-cdf.test(um_s, "x")
ks.rand
plot(ks.rand)

cvm.rand<-cdf.test(um_s, "x", "cvm")
cvm.rand

ad.rand<-cdf.test(um_s, "x", "ad")
ad.rand

bt1<-berman.test(um_s, "x") 
bt1

bt2<-berman.test(um_s, "x", "Z2") 
bt2

mat_im<-cbind(firms.sub$coords.x1, firms.sub$coords.x2, firms.sub$dist)
mat_pix<-as.im(mat_im, W)
ks.rand.im<-cdf.test(um_s, mat_pix)
ks.rand.im

cvm.rand.im<-cdf.test(um_s, mat_pix, "cvm")
cvm.rand.im

ad.rand.im  <- cdf.test(um_s, mat_pix, "ad")
ad.rand.im

bt1.im <- berman.test(um_s, mat_pix) 
bt1.im

bt2.im <- berman.test(um_s, mat_pix, "Z2") 
bt2.im

plot(ks.rand)
plot(ks.rand.im)

#8.3. Distance-based analysis of the unmarked point pattern
#8.3.1. Distance-based measures
#8.3.1.1. Ripley’s K function

Ki<-Kinhom(um_s)
Ki
plot(Ki) #Fig.8.5a

#8.3.1.2. F function

Fi <- Finhom(um_s)
plot(Fi) # Fig.8.5b

#8.3.1.3. G function

Gi <- Ginhom(um_s)
plot(Gi) # Fig.8.5c

#8.3.1.4. J function

Ji<-Jinhom(um_s)
plot(Ji) # Fig.8.5d
 
#8.3.1.5. Distance-based CSR tests

ce.test <- clarkevans.test(um_s)
ce.test

ht <- hopskel.test(um_s)
ht

#8.3.2. Monte-Carlo tests
#8.3.3. Envelopes

E <- envelope(um_s, Linhom, nsim = 5, verbose=FALSE) # Fig.8.6a
plot(E)

#8.3.4. Non-graphical tests

dclf.xr <- dclf.test(um_s, Lest, nsim=19)
dclf.xr

mad.xr <- mad.test(X.rand, Lest, nsim=19)
mad.xr

#8.4. Selection and estimation of a proper model for unmarked point pattern
#8.4.1. Theoretical note
#8.4.2. Choice of parameters

r1 <- seq(1,10,by=0.05) # declaring the vector of possible radiuses 
D1 <- data.frame(r=r1) # conversion to the class data.frame
fp1 <- profilepl(D1, Strauss, um_s ~ 1, aic=TRUE, fast=TRUE, verbose=FALSE)
fp1

m1 <- ppm(um_s ~ 1, PairPiece(1:10)) # check for all possible radia
f1 <- fitin(m1) # fitting step function
plot(f1, main="") # Fig.8.6b

# stationary Geyer saturation model
# setting r from 1 to 10 and s from 1 to 3
df <- expand.grid(r=seq(1,10, by=0.05), sat=c(1,3)) 
pG <- profilepl(df, Geyer, um_s ~ 1, aic=TRUE, verbose=FALSE)
pg

df1 <- expand.grid(r=seq(1,10, by=0.05), sat=c(1,3))
pG1 <- profilepl(df1, Geyer, um_s ~ x, aic=TRUE, verbose=FALSE)
pG1

#8.4.3. Estimation and results

as.ppm(pG)
as.ppm(pG1)
anova(as.ppm(pG), as.ppm(pG1), test="Chi")
diagnose.ppm(as.ppm(pG1), type="Pearson", envelope=TRUE, nsim=19) # Fig.8.7a
qqplot.ppm(as.ppm(pG1), nsim=19) # Fig.8.7b

#8.4.4. Conclusions
#8.5. Intensity-based analysis of marked point pattern
#8.5.1. Segregation test

s<-segregation.test(mm_s, nsim=19)
s

#8.6. Correlation and spacing analysis of the marked point pattern
#8.6.1. Analysis under assumption of stationarity
#8.6.1.1. K function variations for multitype pattern

Kfm<-Kcross(mm_s,"F", "M")
plot(Kfm)

Kdi<-Kdot(mm_s, "G")
plot(Kdi)

#8.6.1.2. Mark connection function

ma<-markconnect(mm_s, "J", "K")
plot(ma)

#8.6.1.3. Analysis of within and between types of dependence

mc<-markcorr(mm_s)
plot(mc)

Ic <- Iest(mm_s)
plot(Ic)

#8.6.1.4. Randomisation test of components’ independence

mm_s$window # initial window

# setting new window
window(mm_s) <- owin(c(1510.01,1686.7666), c(4052.118,4278.901)) 

mm_s$window # changed window
#window: rectangle = [1510.01, 1686.7666] x [4052.118, 4278.901] km

E<-envelope(mm_s, Lcross, nsim=99, i="A", j="C", simulate=expression(rshift(mm_s, radius=35)))
plot(E)

#8.6.2. Analysis under assumption of non-stationarity
#8.6.2.1. Inhomogeneous K function variations for multitype pattern

Kfmi <- Kcross.inhom(mm_s, "F", "M")
plot(Kfmi)

Kdii<-Kdot.inhom(mm_s, "G")
plot(Kdii)

#8.7. Selection and estimation of a proper model for unmarked point pattern
#8.7.1. Theoretical note
#8.7.2. Choice of optimal radius

s <- split(mm_s) # splitting into 20 different patterns 
s$F$marks <- as.factor(rep("F", 82)) # attaching mark values
s$G$marks <- as.factor(rep("G", 204))
s$M$marks <- as.factor(rep("M", 46))
big_pattern <- superimpose(s$F, s$G, s$M) # big pattern of 3 industries
fm <- superimpose(s$F, s$M) # pattern of F and M industries
fg <- superimpose(s$F, s$G) # pattern of F and G industries
mg <- superimpose(s$G, s$M) # pattern of M and G industries

#8.7.3. Within-industry interaction radius 

# big marked pattern with 3 mark types
RR <- data.frame(R=seq(30,40,by=0.05)) # specifying interval
MS <- function(R) { MultiStrauss(radii=diag(c(R,R,R))) } # with interaction 
pm <- profilepl(RR, MS, X.r2~marks, verbose=FALSE) # optimalization
pm # suggested radius of within industry interaction is 30.4 km

# checking for each industry separately
r1 <- seq(30,40,by=0.05)
D1 <- data.frame(r=r1)
fp1 <- profilepl(D1, Strauss, s$F ~ 1)
fp1 # 30.55 km for F industry

r2 <- seq(30,40,by=0.05)
D2 <- data.frame(r=r2)
fp2 <- profilepl(D2, Strauss, s$G ~ 1, verbose=FALSE)
fp2 # 30.9 km for G industry

r3 <- seq(30,40,by=0.05)
D3 <- data.frame(r=r3)
fp3 <- profilepl(D3, Strauss, s$M ~ 1, verbose=FALSE)
fp3 # 30 km for M industry

#8.7.4. Between-industry interaction radius

r4 <- seq(30,40,by=0.01)
D4 <- data.frame(r=r4)
fp4<-profilepl(D4, Strauss, fm~marks, aic=TRUE, fast=TRUE, verbose=FALSE)
fp4 # 30 km

r5 <- seq(30,40,by=0.01)
D5 <- data.frame(r=r5)
fp5<-profilepl(D5, Strauss, fg~marks, aic=TRUE, fast=TRUE, verbose=FALSE)
fp5 # 30.54 km

r6<-seq(30,40,by=0.01)
D6<-data.frame(r=r6)
fp6<-profilepl(D3, Strauss, mg~marks, aic=TRUE, fast=TRUE, verbose=FALSE)
fp6 # 30.05 km

#8.7.5. Estimation and results
#8.7.6. Model with no between-industry interaction

rr1 <- diag(c(30.4, 30.4, 30.4))
fit1 <- ppm(X.r2~marks, MultiStrauss(rr1))
fit1

rr2 <- diag(c(30.55, 30.45, 30.9))
fit2 <- ppm(X.r2~marks, MultiStrauss(rr2))
fit2

# additive trend
rr3 <- diag(c(30.55, 30.45, 30.9))
fit3 <- ppm(X.r2~marks+x, MultiStrauss(rr3))
fit3

# multiplicative trend
rr4 <- diag(c(30.55, 30.45, 30.9))
fit4 <- ppm(X.r2~marks*x, MultiStrauss(rr4))
fit4

#8.7.7. Model with all possible interactions

tt1<-matrix(c(30.55, 30.54, 30, 30.54, 30.45, 30.05, 30, 30.05, 30.9), nrow=3, ncol=3)
fit5 <- ppm(X.r2~marks, MultiStrauss(tt1))
fit5

### additive trend
tt1<-matrix(c(30.55, 30.54, 30, 30.54, 30.45, 30.05, 30, 30.05, 30.9), nrow=3, ncol=3)
fit6<-ppm(X.r2~marks+x, MultiStrauss(tt1))
fit6

### multiplicative trend
tt1<-matrix(c(30.55, 30.54, 30, 30.54, 30.45, 30.05, 30, 30.05, 30.9), nrow=3, ncol=3)
fit7<-ppm(X.r2~marks*x, MultiStrauss(tt1))
fit7

#8.8. Spatial interpolation methods - kriging 
#8.8.1. Basic definitions 
#8.8.2. Description of chosen kriging methods 

summary(firms$empl)

#8.8.3. Data preparation for the study

table(firms$empl)
# cleaning data
firms <- firms[ which(firms$empl!=5),]
firms <- firms[ which(firms$empl!=600),]
firms <- firms[ which(firms$empl!=1500),]

#8.8.4. Estimation and discussion

firms$r<-runif(dim(firms)[1]) #random variable - uniform distribution [0,1]
# new objects are also of class SpatialPointsDataFrame:
input <- firms[firms$r<0.8, ] # choosing 80% of data as input data
output <- firms[firms$r>0.8, ] # choosing 20% of data as output data

library(automap)
ok.var<-autofitVariogram(empl~1, input) # ordinary kriging
plot(ok.var)

# universal kriging based on function of Cartesian coordinates
uk.var.1<-autofitVariogram(empl~coords.x1+coords.x2, input)
plot(uk.var.1)

# universal kriging based on distance to Lublin
uk.var.2<-autofitVariogram(empl~dist, input)
plot(uk.var.2)

## ordinary
ok.xy <- autoKrige(empl~1, input, output, verbose=FALSE)

## universal, x+y
uk.xy <- autoKrige(empl~x+y, input, output, verbose=FALSE)

## universal, dist
uk.dist <- autoKrige(empl~dist, input, output, verbose=FALSE)

# Fig.8.12
class(ok.xy$krige_output)

names(ok.xy$krige_output)

## original values
result0<-automapPlot(output,"empl", main="Original \n data")
result0

## ordinary
result1<-automapPlot(ok.xy$krige_output,"var1.pred", main="Ordinary kriging")
result1

## universal, x+y
result2<-automapPlot(ok.xy$krige_output,"var1.pred", main="Universal kriging, \n Cartesian coordinates function")
result2

## universal, dist
result3<-automapPlot(ok.xy$krige_output,"var1.pred", main="Universal kriging, \n distance to Lublin")
result3

library(Metrics)

rmse_ord <- rmse(output$empl, ok.xy$krige_output@data$var1.pred)
rmse_un_xy <- rmse(output$empl, uk.xy$krige_output@data$var1.pred)
rmse_un_dist <- rmse(output$empl, uk.dist$krige_output@data$var1.pred)

rmse_ord
rmse_un_xy
rmse_un_dist
