##############################################
#Applied Spatial Statistics and Econometrics: Data Analysis in R (Routledge, 2020) 
#Przestrzenne metody ilościowe w R: statystyka, ekonometria, uczenie maszynowe, analiza danych (CeDeWu, 2020)
#Editor: Katarzyna Kopczewska 
#Authors: Katarzyna Kopczewska, Maria Kubara, Piotr Ćwiakowski, Mateusz Kopyt, Piotr Wójcik, Alessandro Festi, Kateryna Zabarina
#This book is a part of project supported by the Polish National Science Center (NCN) on „Spatial econometric models with fixed and changing neighborhood structure. Application for real estate valuation and business location” (OPUS 12, contract no. UMO-2016/23/B/ HS4/02363).
#All sample data used in the book and the codes presented in the content of the book were placed on https://github.com/kkopczewska/spatial_book 
##############################################

#Chapter 6
#Geographically Weighted Regression - modelling spatial heterogeneity
#Piotr Ćwiakowski, orcid.org/0000-0003-3181-7227

#6.1 Geographically weighted regression
#6.2 Basic estimation of GWR model
#6.2.1 Estimation of the reference OLS model

# loading packages and data
library(car) # car:: includes VIF statistics
mydata<-read.csv2('NTS4_Polish_data.csv') # loading data
mydata12<-mydata[mydata$year== \2012, ] # selecting data for year 2012

# Y -	average salary Polish = 100% 	(XA31) 
mydata12$y <- mydata12$XA31
# X1 	share of people employed in services (XA05/XA20) 
mydata12$x1 <- mydata12$XA05/mydata12$XA20
# X2 	unemployment rate (XA06) 
mydata12$x2 <- mydata12$XA06
# X3 	number of companies in Poland = 100% (XA28/mean(XA28)) 
mydata12$x3 <- mydata12$XA28/mean(mydata12$XA28, na.rm = TRUE)
# X4 	hedges by location 	(XA40/mean(XA40)) 
mydata12$x4 <- mydata12$XA40/mean(mydata12$XA40, na.rm = TRUE)

# Linear regression model
lm.model<-lm(y ~ x1 + x2 + x3 + x4, data=mydata12)
summary(lm.model)

# ComputingVIF statistics
vif(lm.model)

#6.2.2 Choosing the optimal bandwidth for a dataset

# libraries
library(rgdal)
library(maptools)
library(spgwr)

# loading the map
nts4<-readOGR("#R8_0 Data", "poviats") # 380 units
nts4<-spTransform(nts4, CRS("+proj=longlat +datum=NAD83"))

# poviat centroids coordinates
crds<-coordinates(nts4)
colnames(crds)<-c("cx", "cy")

# replace data.frame with SpatialPointsDataFrame
map<-SpatialPointsDataFrame(data = mydata12, coords = crds)

# Choosing the optimal number of nearest neighbors
bw<-gwr.sel(y ~ x1 + x2 + x3 + x4, data=map, adapt=T, RMSE=T)

# Choosing the optimal bandwidth
bw <- gwr.sel(y ~ x1 + x2 + x3 + x4, data = map, adapt = F, RMSE = T)

# Auxiliary variables
bw_adapt <- numeric(5)
bw_fixed <- numeric(5)
i = 1

# A loop looking for the optimal bandwidth for different kernels
for(kernel in c('gaussian', 'exponential', 'bisquare', 'tricube', 'boxcar')){
bw_adapt[i]<-bw.gwr(y~x1+x2+x3+x4, data=map, kernel=kernel, adaptive=T)
bw_fixed[i]<-bw.gwr(y~x1+x2+x3+x4, data=map, kernel=kernel, adaptive=F)
i = i + 1}

results<-data.frame(
   Kernel=rep(c('gaussian','exponential','bisquare','tricube','boxcar'),2), 
      Typ = c(rep(' adaptive ', 5), rep(' constant ', 5)),
      RSS = c(47322.13, 47400.55, 47334.44,47383.18,47542.08,47458.59,  
          47542.08,47458.59 ,47334.89, 47405.07))

#6.2.3 Local geographically weighted statistics

# computing spatial statistics
stats<-spgwr::gw.cov(map, 'y', adapt=T, bw=0.6816255, gweight=gwr.gaussian, longlat=FALSE)

# list boxes with results (e.g. average, standard deviation, standard error)
names(stats$SDF)

# Saving vectors with parameters to variables
b1<-stats$SDF$mean.V1

# Setting colors for different values in the distribution of parameters x1
brks<-c(min(b1), mean(b1) - sd(b1), mean(b1), mean(b1) + sd(b1), max(b1))

# color palette
cols<-c("steelblue4", "lightskyblue", "thistle1", "plum3")

# Graph (map, legend title)
plot(nts4, col = cols[findInterval(b1, brks)])
title(main="Spatial distribution of the geographically weighted\n mean of the average salary")
legend("bottomleft", legend=leglabs(round(brks, 2)), fill=cols, bty="n")

# Saving vectors with parameters to variables
b1 <- stats$SDF$sd.V1

# Graph (map, legend title)
plot(nts4, col = cols[findInterval(b1, brks)])
title(main="Spatial distribution of the geographically weighted\nstandard deviation of the average salary")
legend("bottomleft", legend=leglabs(round(brks, 2)), fill=cols, bty="n")

#6.2.4 Geographically weighted regression estimation

# Estimation of the GWR model
gwr.model <- gwr(y ~ x1 + x2 + x3 + x4, data = map, adapt = bw)
gwr.model  # Summary print

par(mfrow=c(2, 2)) # 2x2 graphic window
cols<-c("steelblue4", "lightskyblue", "thistle1", "plum3") # color palette

# Saving vectors with parameters to variables
b1 <- gwr.model$SDF$x1
b2 <- gwr.model$SDF$x2
b3 <- gwr.model$SDF$x3
b4 <- gwr.model$SDF$x4

# Setting color ranges for different x1 parameter values
brks <- c(min(b1), mean(b1) - sd(b1), mean(b1), mean(b1) + sd(b1), max(b1))

plot(nts4, col = cols[findInterval(b1, brks)]) # Graph (map, legend title)
title(main="The average impact of the percentage of employees in the services sector on the average wage in the poviat")
legend("bottomleft", legend=leglabs(round(brks, 2)), fill=cols, bty="n")

# Setting color ranges for different x2 parameter values
brks <- c(min(b2), mean(b2) - sd(b2), mean(b2), mean(b2) + sd(b2), max(b2))

plot(nts4, col=cols[findInterval(b2, brks)]) # Graph (map, legend title)

title(main="Impact of the unemployment rate on average wages in poviat")
legend("bottomleft", legend=leglabs(round(brks, 2)), fill=cols, bty="n")

# Setting color ranges for different x3 parameter values
brks <- c(min(b3), mean(b3) - sd(b3), mean(b3), mean(b3) + sd(b3), max(b3))

plot(nts4, col=cols[findInterval(b3, brks)]) # Graph (map, legend title)
title(main="Impact of the percentage of companies registered in the poviat on the average remuneration in the poviat")
legend("bottomleft", legend=leglabs(round(brks, 2)), fill=cols, bty="n")

# Setting color ranges for different x4 parameter values
brks <- c(min(b4), mean(b4) - sd(b4), mean(b4), mean(b4) + sd(b4), max(b4))

plot(nts4, col=cols[findInterval(b4, brks)]) # Graph (map, legend title)
title(main="Impact of hedges in the poviat on average salary in poviat")
legend("bottomleft", legend=leglabs(round(brks, 2)), fill=cols, bty="n")

par(mfrow=c(1, 1)) # Return to default settings (1 chart in 1 window)

#6.2.5 Basic diagnostic tests of the GWR model

LMZ.F1GWR.test(gwr.model)
LMZ.F2GWR.test(gwr.model)
BFC99.gwr.test(gwr.model)
LMZ.F3GWR.test(gwr.model)

library(spdep)
neib<-spdep::knearneigh(crds, k=50) # Counting the closest neighbors
neib.nb<-spdep::knn2nb(neib)
spgwr::gwr.morantest(gwr.model, spdep::nb2listw(neib.nb))
spdep::lm.morantest(lm.model, spdep::nb2listw(neib.nb))

# Model estimation
bw1<-bw.gwr(y~x1+x2+x3+x4, data=map, kernel="gaussian", adaptive=T)

# Model estimation with Euclidean distance
gwr.res<-gwr.basic(y~x1+x2+x3+x4, data=map, bw=bw1, p=2, adaptive=T, kernel='gaussian')
gwr.res # Results printout

source('#R8 - functions.R')
gwr.bootstrap2(y ~ x1 + x2 + x3 + x4, data=map, p=2, R=99, approach='CV', k.nearneigh=5, adaptive=T, kernel='gaussian', longlat=F, bw=bw)
gwr.montecarlo(y~x1+x2+x3+x4, data=map, nsims=999, bw=bw1, adaptive=T)

#6.2.6 Testing the significance of parameters in GWR

# Significance tests of local regression parameters with p-value correction
# by Fotheringham – Byrne
gwr.t.adjust(gwr.res)$results$fb

#6.2.7 Selection of the optimal functional form of the model

# Forward regression counting
model.sel <- model.selection.gwr(DeVar = 'y', InDeVars = c('x1', 'x2', 'x3', 'x4'), data = map, kernel = "gaussian", adaptive = TRUE, bw = 259)

# Sorting models by AICc
sorted.models<-model.sort.gwr(model.sel,numVars=4,ruler.vector= model.sel[[2]][,3])

# Save list of sorted models
model.list <- sorted.models[[1]]

# Illustration of the steps of step regression
model.view.gwr('y', c('x1', 'x2', 'x3', 'x4'), model.list = model.list)

# Statistics print of sorted models
sorted.models[[2]]

#6.2.8 GWR with heteroskedastic random error

gwr_het <- gwr.hetero(y ~ x1 + x2 + x3 + x4, data = map, regression.points = map, longlat = T, bw = bw, adaptive = TRUE, kernel = 'gaussian')
summary(gwr_het)

#6.3 The problem of collinearity in GWR models
#6.3.1 Diagnosing collinearity in GWR

library(GGally) 
# Saving the revision coefficients as data.frame columns
wsp <- data.frame(x1 = gwr.model$SDF$x1, x2 = gwr.model$SDF$x2,
         x3 = gwr.model$SDF$x3, x4 = gwr.model$SDF$x4)
ggpairs(wsp) # Generating a correlogram

library(GWmodel)

# Counting diagnostic statistics in GWR 
diag_gwr<-gwr.collin.diagno(y~x1+x2+x3+x4, map, bw=floor(bw*380), 
kernel="gaussian", adaptive=T)
summary(diag_gwr)
diag_gwr$corr.mat
par(mfrow=c(2, 3)) # 2x2 graphic window

# vector with headers for individual maps
variables=c('x1 & x2','x1 & x3','x1 & x4','x2 & x3','x2 & x4','x3 & x4')

# generating graphs in a loop
for (i in 5:10){
 print(i)
 b1<-diag_gwr$corr.mat[, i] # Saving vector with parameters
# Setting colors for different values in the distribution of parameters x1
 brks<-c(min(b1), mean(b1)-sd(b1), mean(b1), mean(b1)+sd(b1), max(b1))
 cols<-c("steelblue4", "lightskyblue", "thistle1", "plum3")# color palette
plot(nts4, col=cols[findInterval(b1, brks)]) # Graph (map, legend title)
 title(main=paste0("local correlation of:", variables[i - 4]))
 legend("bottomleft", legend=leglabs(round(brks, 2)), fill=cols, bty="n")}
par(mfrow=c(1, 1))

# Correlation matrix for the whole set
cor(mydata12[, c('x1', 'x2', 'x3', 'x4')])
diag_gwr$VIF
summary(diag_gwr$VIF)
head(diag_gwr$local_CN, 30)
head(diag_gwr$VDP)

library(gwrr) # Loading packages

gwr_lasso<-gwl.est(y~x1+x2+x3+x4, locs=crds, kernel="gauss", data= as.data.frame(map)) # Model estimation

summary(gwr_lasso) # Results
gwr_lasso$phi 		# Optimal bandwidth for GWL
gwr_lasso$rsquare		# GWL R-square
gwr_lasso$RMSE		# RMSE (in-sample) GWL
gwr_lasso$RMSPE		# RMSE (out-of-sample) GWL

# Model estimation with in-sample prediction option
gwr.model <- gwr(y ~ x1 + x2 + x3 + x4, data = map, adapt = .68, hatmatrix = TRUE, predictions = TRUE)

# Comparison of in-sample prediction errors
Metrics::rmse(mydata12$y, gwr.model$SDF$pred)

# Linear Regression
Metrics::rmse(mydata12$y, predict(lm.model, mydata12))

# GWR (in-sample)
Metrics::rmse(mydata12$y, gwr.model$SDF$pred)

# GWL (in-sample)
Metrics::rmse(mydata12$y, gwr_lasso$yhat)
	
# Bandwidth estimation
bw <- bw.gwr.lcr(y ~ x1 + x2 + x3 + x4, data = map, kernel = "gaussian", adaptive = TRUE)

gwrr_model <- gwr.lcr(y ~ x1 + x2 + x3 + x4, data = map, bw = bw, kernel = "gaussian", adaptive = TRUE, lambda.adjust = F, lambda = 0)
gwrr_model

#6.4. Mixed GWR

model.mixed<-gwr.mixed(y~x1+x2+x3+x4, data=map, fixed.vars=c('x3', 'x4'), bw=bw, diagnostic=TRUE, intercept.fixed=FALSE, adaptive=TRUE, kernel='gaussian')
model.mixed$aic
lm(y ~ x1 + x2 + x3 + x4, data = map)

#6.5. Robust regression in the GWR model

gwr.robust(y ~ x1 + x2 + x3 + x4, data = map, bw = bw, adaptive = TRUE, kernel = 'gaussian', F123.test = FALSE, filtered = TRUE, cut.filter = 3)

#6.6. Geographically and Temporally Weighted Regression (GTWR)

# Counting the time variable
mydata$time <- as.Date(as.character(mydata$year), format = '%Y')

# Separating columns from the set
mydata_t <- mydata[, c('y', 'x1', 'x2', 'x3', 'x4', 'time', )]

# Coordinates vector for each observation in the panel
crds2 <- do.call("rbind", replicate(10, crds, simplify = FALSE))
map <- SpatialPointsDataFrame(data = mydata, coords = crds2)

x<-st.dist(coordinates(map), obs.tv = mydata$time, p=2, theta=0, longlat=F,lamda=0.05,t.units = "auto",ksi=0)

bw_st<-bw.gtwr(y ~ x1 + x2 + x3 + x4, map, mydata$time, approach="CV", kernel="gaussian", adaptive=T, verbose=T, st.dMat=x)

model <- gtwr(y ~ x1 + x2 + x3 + x4, map, regression.points=NULL, mydata$time, unique(mydata$time), bw_st, kernel="bisquare", adaptive=FALSE, p=2, theta=0, longlat=F,lamda=0.05,t.units = "auto",ksi=0, st.dMat=x) 
