##############################################
#Applied Spatial Statistics and Econometrics: Data Analysis in R (Routledge, 2020) 
#Przestrzenne metody ilościowe w R: statystyka, ekonometria, uczenie maszynowe, analiza danych (CeDeWu, 2020)
#Editor: Katarzyna Kopczewska 
#Authors: Katarzyna Kopczewska, Maria Kubara, Piotr Ćwiakowski, Mateusz Kopyt, Piotr Wójcik, Alessandro Festi, Kateryna Zabarina
#This book is a part of project supported by the Polish National Science Center (NCN) on „Spatial econometric models with fixed and changing neighborhood structure. Application for real estate valuation and business location” (OPUS 12, contract no. UMO-2016/23/B/ HS4/02363).
#All sample data used in the book and the codes presented in the content of the book were placed on https://github.com/kkopczewska/spatial_book 
##############################################

#Chapter 1
#Basic operations in the R software
#Mateusz Kopyt, orcid.org/0000-0001-5285-7792

#1.1 About the R software
#1.2 The R software interface
#1.2.1 R Commander
#1.2.2. RStudio
#1.3 Using help

?cor
help("cor")

?? correlation
help.search("correlation")

apropos("cor")

library(help="stats")

example("cor")

cor 	# only the beginning and end of the command code will be shown

help.start()

demo(colors)

#1.4 Additional packages

search()
update.packages()
library("spdep")

requiredPackages<-c("sp", "spdep", "RColorBrewer") # a list of packages
for(i in requiredPackages){
  if(!require(i,character.only = TRUE)) install.packages(i)
  library(i,character.only = TRUE) }

detach("package:spdep", unload=TRUE)

#1.5 R language - basic features
#1.6 Defining and loading data

getwd() # checking the current working directory
setwd("C:/R/Data/") # setting the required working directory - example

library(foreign) # library supporting additional file formats
getwd() # checks the location of the default directory

# loading from a text file
data1<-read.table("data.txt", header=TRUE, sep="\t", encoding="UTF-8") 

# loading from a CSV file
data2<-read.csv("data.csv",header=TRUE, sep=";",dec=".", encoding="UTF-8")

# loading from tab delimited file
data3<-read.delim("data.dat", header=FALSE, sep="\t") 

# loading from a dbf file
data4<-read.dbf("data.dbf") 

# loading from the SPSS format
data5<-read.spss("data.sav", use.value.labels=FALSE, to.data.frame=TRUE) 

# loading from the STATA format
data6<-read.dta("data.dta", convert.factors=FALSE) 

library(gdata)
data7 = read.xls ("myfile.xlsx", sheet = 1, header = TRUE)

#1.7 Basic operations on objects

3+5
vector1<-c(1,2,3,4,5) # vector of numbers 1,2,3,4,5
vector2<-10:20 # vector of integers from 10 to 20
vector3<-seq(5,10,0.2) # a sequence of numbers from 5 to 10 with a step of 0.2

data<-read.csv("data_nts4_2019.csv", header=TRUE, sep=";", dec=",", encoding="UTF-8")

names(data)

class(data)

# converting data to the data.frame class object if possible 
# and create a new object if needed
data.df<-as.data.frame(data) 
str(data) # structure of the object
attributes(dane) # object attributes 

vector3<-seq(5,10,0.2) # vector reminder
new vector3<-vector3 # assignment to a new name
new vector3# display of the object
rm(vector3) # deleting from the object's memory vector3

x<-seq(1, 20, 0.4) # generating a variable x
y<-seq(2,21,0.4)  # generating a variable y
z<-seq(3,22,0.4)  # generating a variable z
xyz<-cbind(x,y,z)  # combining variables into one xyz object 

head(xyz) # display the beginning of the xyz object

names(xyz)  # request to display headers

# adding new names of columns and rows
colnames(xyz)<-c("variable x", "variable y", "variable from")
rownames(xyz)<-rownames(xyz, do.NULL = FALSE, prefix = "Obs.")

is.data.frame(xyz)  # checking if xyz is a data.frame object
xyz.df<-as.data.frame(xyz)  # xyz conversion to data frame

head(xyz.df)  # displaying the xyz object after changes

names(xyz.df)  # request to display column headers
colnames(xyz.df)  # request to display column headers
head(rownames(xyz.df))  # request to display row headers

unempl<-data$XA06
head(unempl)

# observations from 1 to 4 with variables from columns 3 to 5
section<-data[1:4, c(7,9,11)] 
section
# only rows 2,7,10,15 and all columns
section 2<-data[c(2,7,10,15), ]

# rows 1 to 10, but without a selected column - here is the fifth 
# character (-) deletes the given row or column from the result
section3<-data[1:10,-5] 

data15<-data[data$year==2015,]
head(data15) # subset for year 2015

podkarp.or.opol<-data15[data15$voivodeship=="Opolskie" | data15$voivodeship=="Podkarpackie", ]

# combining several variables into one object
employment<-cbind(data15$XA03, data15$XA04, data15$XA05) 

# limiting the collection for increased transparency
employment<-as.data.frame(employment[1:4, ]) 

# giving new headers
colnames(employment)<-c("agriculture", "industry", "services") 

# displaying the object's content
employment

# a new object containing a marker (ind) and values
# displaying the content of the object after the stack() function  
zat.stack<-stack(employment) 
zat.stack 
unstack(zat.stack) # return to the original data

data15$XA17a<-data15$XA17 # coping a variable XA17, named XA17a

# creating missing observations coded as 99999
data15$XA17a[c(3,5,9,10)]<-99999 

head(data15$XA17a,12) # display of the first 12 data of variable XA17a

# assigning NA to missing observations
is.na(data15$XA17a)<-data15$XA17a>=99998 
head(data15$XA17a,12) # display of the first 12 data of variable XA17a

#1.8 Basic statistics of the data set

summary(data15)

employment<-as.data.frame(cbind(data15$XA03, data15$XA04, data15$XA05))
colnames(employment)<-c("agriculture", "industry", "services") 

# average calculated from all data.frame object variables using lapply()
lapply(employment,mean,na.rm=T)
# average calculated from all data.frame object variables using sapply()
sapply(employment,mean,na.rm=T) 

# average calculated for one variable (column) with data.frame objects
mean(employment$service, on.rm = TRUE)

var1<-rnorm(1000) # 1000 numbers drawn from the normal distribution
quantile(var1)

# setting the probability thresholds by the user
quantile(var1,  probs=c(1,2,5,95,98,99)/100) 

fivenum(data15$XA06) #position statistics for the unemployment in 2015

class(data$voivodeship) # checking if the variable is factor

levels(data$voivodeship) # number of classes / levels

nlevels(data$voivodeship)  # number of classes / levels

cor(data15$XA06,data15$XA30)
cor.test(data15$XA06,data15$XA30)

# employed per capita - number of employees divided by total population
# new variable empl.pc, added to the data15 object
data15$empl.pc<-data15$XA02/(data15$XA19+data15$XA20+data15$XA21)

# creating a new object containing only variables: 
# unemployment rate, salary, employed per capita
variables.df<-data.frame(cbind(data15$XA06, data15$XA30, data15$empl.pc))
colnames(variables.df)<-c("unemployment rate", "salary", "employed per capita")

# correlation matrix, the rounding function was used 
# up to two decimal places to increase readability
round(cor(variables.df, use="pairwise"),2)

# correlation scatterplot
pairs(variables.df) 

variable<-data15$XA30

# standardising expression variable - the new variable is Z_ variable
Z_variable<-(variable-mean(variable))/sd(variable)

# the average of the standardized variable is very close to zero
mean(Z_variable)

# the variance is equal to 1
var(Z_variable)

variable1<-data15$XA30
Z_variable1<-scale(variable1) # standardized variable
mean(Z_ variable1)
var(Z_ variable1)

#1.9 Basic visualisations
#1.9.1 Scatterplot and line chart

data<-read.csv("data_nts4_2019.csv", header=TRUE, sep=";", dec=",", encoding="UTF-8")

# aggregation of data with respect to the year
unemployment <-aggregate(data$XA06, by=list(data$year), mean, na.rm=TRUE) 
unemployment
par(mfrow=c(1,2), mar=c(2,2,2,1))
plot(unemployment$x) # the simplest point plot

# line chart with additional options
plot(unemployment$x, type= "l", lwd=2, axes=FALSE, xlab="year", ylim=c(10,20))
axis(1, at=1:10, labels=unemploymet$Group.1, cex=0.8)
axis(2)
abline(h=(5:10)*2, lty=3)
abline(v=(1:10)*1, lty=3)
points(unemploymet$x, pch=21, bg="red", cex=1.5)
title(main=" Average unemployment rate in Poland based on poviat data", cex.main=0.8)
legend(3,20, pch=21, pt.bg="red", col="black", lwd=2, c("unemployment rate"), bty="n", cex = 0.6)
text(1:10, unemploymet$x+0.5, round(unemploymet$x,2), cex=0.6)

x<-seq(1,25,1) # generating the x variable
y<-2*x^2  # generating the y variable
# dividing the chart area into parts, and determining the margins
par(mfrow=c(2,3), mar=c(2,2,2,2)) 
plot(y, type="p", main="typ p")
plot(y, type="l", main="typ l")
plot(y, type="o", main="typ o")
plot(y, type="h", main="typ h")
plot(y, type="s", main="typ s")
plot(y, type="S", main="typ S")

#1.9.2 Column chart

# loading of data
data<-read.csv("data_nts4_2019.csv", header=TRUE, sep=";", dec=",", encoding="UTF-8")

# Fig.1.9a
pprod<-aggregate(data$XA19, by=list(data$year), sum, na.rm=TRUE)
colnames(pprod)<-c("year","l_pprod")

# the names.arg option gives labels under the bars
barplot(pprod$l_pprod/1000, col="grey", ylim=c(0,8000), ylab="in thous.",
        names.arg=pprod$year, cex.axis=0.8, main="Pre-working age population", cex.names=0.8) 
abline(h=c(6000,7000,8000), lty=3, col="red") # horizontal lines

# Fig.1.9b
# stacked bar graph
preprod<-aggregate(data$XA19, by=list(data$year), sum, na.rm=TRUE)
prod<-aggregate(data$XA20, by=list(data$year), sum, na.rm=TRUE)
postprod<-aggregate(data$XA21, by=list(data$year), sum, na.rm=TRUE)
population<-cbind(preprod, prod$x, postprod$x)
colnames(population)<-c("year", "pre-working", "working", "post-working")

# converting the data.frame object to the matrix for the barplot command
population.m<-as.matrix(population) 
barplot(t(population.m[,2:4]/1000), ylim=c(0,40000), cex.axis=0.8, names.arg=population.m[,1], legend.text=TRUE, args.legend=list(x="right", bg="white"), cex.names=0.8, main="Population structure by years")
abline(h= population.m[1,2]/1000, lty=3, lwd=2, col="blue")
abline(h=sum(population.m[1,2:3]/1000), lty=3, lwd=2, col="blue")
abline(h=sum(population.m[1,2:4]/1000), lty=3, lwd=2, col="blue")

t(population.m[,2:4])

#1.9.3 Pie chart

# simple pie chart
data15<-data[data$year==2015,]
structure<-aggregate(cbind(XA19, XA20, XA21) ~ voivodeship, data=data15, sum)
colnames(structure)<-c("voivodeship", "Pre-working" "work.", "Post-work.")
structure_m<-structure[structure$voivodeship=="Mazowieckie",]
structure_m<-structure_m[2:4] # deleting the name of the voivodeship

# 3D pie chart
# dividing the chart area into 2 parts, and determining the margins
par(mfrow=c(1,2), mar=c(2,2,2,2))
# converting the data.frame object into a numeric vector
pie(as.numeric(structure_m), labels=names(structure_m), cex=0.6) 

library(plotrix) # loading the required package
pie3D(as.numeric(structure_m),edges=1000,radius=1.3,height=0.2,theta=pi/4,start=0, explode=0.20, col=heat.colors(3),labels=names(structure_m), labelcex=0.7)

#1.9.4 Boxplot

data<-read.csv("data_nts4_2019.csv", header=TRUE, sep=";", dec=",")
data15<-data[data$year==2015,]
boxplot(data15$XA06, col="grey78", ylab="unemployment rate", 
        main=" Unemployment rate in poviats in 2015")

a<-aggregate(data15$XA06, by=list(data15$voivodship), mean, na.rm=TRUE)
a$ID<-c(1:16)
colnames(a)<-c("woj", "x", "ID")
boxplot(data15$XA06~data15$voivodship, axes=FALSE, ylim=c(0,65), col="bisque", border="bisque4")

# average unemployment rate line
abline(h=mean(data15$XA06, na.rm=TRUE), lty=3, col="red") 

# axis
axis(1, at=1:16, labels=a$ID, cex.axis=0.8)
axis(2, at=(0:6)*10, cex.axis=0.8, ylab="%")

# legend text
for(i in 1:16){
text(1,60-3.5*i, a$ID[i], cex=0.6)
text(4,60-3.5*i, a$woj[i], cex=0.6)}
for(i in 9:16){
text(8,60-3.5*(i-8), a$ID[i], cex=0.6)
text(11,60-3.5*(i-8), a$woj[i], cex=0.6)}

title(main="The unemployment rate in 2015 by voivodships", cex.main=0.8,
      sub="Data aggregated from the level of poviats", cex.sub=0.7)

head(colors(),12)

#1.10 Regression in examples

plot(log(data15$XA30),data15$XA06, xlab="Logarithm of average salary in PLN", ylab="Registered unemployment rate (in%)") # Fig.1.11

model1<-lm(XA06~log(XA30), data=data15)
model1  # regression result - basic version
summary(model1) # regression result - full version

plot(log(data15$XA30),data15$XA06, xlab="Logarithm of average salary in PLN", ylab="Registered unemployment rate (in%)")
abline(model1) # Fig.1.11

intercept<-model1$coefficients[1]  # isolation of the free word
slope<-model1$coefficients[2] # extracting the slope of the regression line

intercept
slope

par(mfrow=c(1,2)) # option to show two charts side by side
res<-residuals(model1) 
plot(res, ylab="Residual") 
abline(h=0, lty=2)  
title(main=" Residual scatter plot")

# histogram of residuals
hist(res, breaks=30, main="Residual histogram", freq = FALSE, xlab="Residual")

# creation of the normal distribution density function 
# with parameters consistent with the empirical distribution of the rest
mean.res<-mean(res)
sd.res<-sd(res)
x<-seq(min(res), max(res),length=100)
y<-dnorm(x, mean.res, sd.res)
lines(x,y)  # line of theoretical normal distribution

model1.fit<-predict(model1)  # theoretical values obtained from the model 
# error as a difference between empirical and theoretical values 
error<-data15$XA06-model1.fit 

shapiro.test(data15$XA30) # normality test for the distribution of unemployment variable
shapiro.test(res) # normality test of residual distribution 
