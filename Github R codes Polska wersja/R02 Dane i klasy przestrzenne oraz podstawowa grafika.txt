##############################################
#Przestrzenne metody ilościowe w R: statystyka, ekonometria, uczenie maszynowe, analiza danych
#Redakcja Katarzyna Kopczewska
#Autorzy: Katarzyna Kopczewska, Maria Kubara, Piotr Ćwiakowski, Mateusz Kopyt, Piotr Wójcik, Alessandro Festi, Kateryna Zabarina
#Warszawa, 2020, CeDeWu
#Wydanie książki zostało sfinansowane z grantu Narodowego Centrum Nauki (NCN) pt. Modele ekonometryczne przestrzenne ze stałą i zmienną strukturą sąsiedztwa. Zastosowanie do wyceny nieruchomości i lokalizacji firm (OPUS 12, umowa nr UMO-2016/23/B/HS4/02363).
#Książka została wydana w angielskiej wersji językowej jako: Applied Spatial Statistics and Econometrics: Data Analysis in R (redakcja Katarzyna Kopczewska, autorzy: Katarzyna Kopczewska, Maria Kubara, Piotr Ćwiakowski, Mateusz Kopyt, Piotr Wójcik, Alessandro Festi, Kateryna Zabarina), Routledge, 2020
##############################################

#Rozdział 2
#Dane i klasy przestrzenne oraz podstawowa grafika 
#Katarzyna Kopczewska

#2.1 Wczytywanie i podstawowe operacje na danych przestrzennych wektorowych

library(rgdal)
library(sp)

# wczytywanie plików shapefile
pl<-readOGR(".", "Panstwo") # 1 jedn. 
woj<-readOGR(".", "wojewodztwa") # 16 jedn. 
pow<-readOGR(".", "powiaty") # 380 jedn. 

# zmiana projekcji
pow<-spTransform(pow, CRS("+proj=longlat +datum=NAD83"))
woj<-spTransform(woj, CRS("+proj=longlat +datum=NAD83"))
pl<-spTransform(pl, CRS("+proj=longlat +datum=NAD83"))

class(pow)

pow.df<-as.data.frame(pow)
pow.df<-as(pow, "data.frame") # tożsama operacja do powyższej
class(pow.df)
head(pow.df)
head(pow@data)

# wycztywanie danych powiatowych
dane<-read.csv("dane_pow_2019.csv", header=TRUE, dec=",", sep=";")
summary(dane)
head(dane[,1:6])

# grafika – mapy konturowe osobno
plot(pl)
plot(woj)
plot(pow)

library(maps)
library(GISTools)

# mapa konturowa ze strzałką i skalą
plot(pow)
maps::map.scale(x=14.5, y=49.5, ratio=FALSE, relwidth=0.2, cex=0.8) #z pakietu maps
north.arrow(xb=15.9, yb=50, len=0.1, lab="N", cex.lab=0.8, col='gray10') # z pakietu GISTools# z pakietu GISTools

# mapa konturowa z różą kierunków i siatką geograficzną
plot(woj)
degAxis(1) # z pakietu sp
degAxis(2)
compassRose(15, 49.7,rot=0,cex=1) # z pakietu sp
plot(gridlines(woj), add = TRUE) # z pakietu sp

crds<-coordinates(pow) # koordynaty środków powiatów
head(crds)

# rysunek - mapa administracyjna oraz środki powiatów, rys.2.3a
plot(pl, lwd=3)
plot(pow, add=TRUE)
plot(woj, add=TRUE, lwd=2)
points(crds, pch=21, bg="red", cex=0.8) 

# przygotowanie etykiet i koordynat dla mapy wojewódzkiej
crds.woj<-coordinates(woj)
woj.df<-as.data.frame(woj)
par(mar=c(1,1,1,1))

# podpisywanie regionów w sposób zoptymalizowany
plot(woj)
pointLabel(crds.woj, as.character(woj.df$jpt_nazwa_), cex=0.6)

# podpisywanie regionów w sposób prosty
plot(woj)
text(crds.woj, as.character(woj.df$jpt_nazwa_), cex=0.6)
par(mar=c(5,4,4,2))

# interaktywna edycja nazw regionów
plot(pow, border="grey80")
a<-identify(crds, labels=as.character(pow.df$jpt_nazwa_))
dane[a,c(3,13:15)]

bb<-bbox(pow)
bb
proj4string(pow)

# mapa wojewódzka – dla województwa lubelskiego
# wersja A
woj.df<-as.data.frame(woj)
lub.woj<-woj[woj.df$jpt_nazwa_=="lubelskie", ]
plot(lub.woj, main="Lubelskie NTS2")

# wersja B
plot(woj[woj@data$jpt_nazwa_=="lubelskie",])

# mapa powiatów w ramach województwa lubelskiego
# pow.df<-as.data.frame(pow) #  brak identyfikatora województwa
sub15<-dane[dane$rok==2015, ]
lub.pow<-pow[sub15$wojew_nazwa=="Lubelskie", ]
plot(lub.pow, main="Lubelskie NTS4")

# badanie przynależności powiatów (NTS4) do województw (NTS2)
pow.over<-over(pow, woj) 
head(pow.over)
lub.pow<-pow[pow.over$jpt_nazwa_=="lubelskie", ] # wybór powiatów
plot(lub.pow)

plot(lub.pow) # rys.2.6a
degAxis(1)
degAxis(2)
compassRose(21.5, 52,rot=0,cex=1)

plot(gridlines(lub.woj), add = TRUE) # Rys.2.6b

# wydzielenie dwóch regionów, rys.2.7a
woj.df<-as.data.frame(woj)
woj1<-woj[woj.df$jpt_nazwa_=="kujawsko-pomorskie",]
woj2<-woj[woj.df$jpt_nazwa_=="wielkopolskie",]
plot(woj2) # wspólny rysunek
plot(woj1, lwd=2, add=TRUE)

# połączenie dwóch regionów, rys.2.7b
woj3<-spRbind(woj1, woj2)
woj3.df<-as.data.frame(woj3) 
crds.woj3<-coordinates(woj3)
plot(woj3)
points(crds.woj3)
text(jitter(crds.woj3), labels=woj3.df$jpt_nazwa_)

sub15<-dane[dane$rok==2015, ]
reg1<-unionSpatialPolygons(pow, IDs=sub15$wojew_nazwa) #maptools::
plot(pow) # rys.2.8a
plot(reg1, add=TRUE, border="red", lwd=2)

reg2<-unionSpatialPolygons(woj, IDs=rep(1, times=16)) #maptools
plot(woj) # rys.2.8b
plot(reg2, add=TRUE, border="red")

plot(reg1) # rys.2.9
plot(reg1[1,], border="blue", add=TRUE) # na mapie Dolnośląskie
plot(reg1[16,], border="green", add=TRUE) # na mapie Zachoniopomorskie
lapply(reg1@polygons, slot, "ID")
unlist(lapply(reg1@polygons, slot, "ID"))

# wybrano następujące zmienne:
# kolumna  7 - województwo
# kolumna 26 - XA15 - pracujący ogółem 
# kolumna 32 – XA21 - stopa bezrobocia

dane15.lim<-dane[dane$rok==2015, c(7,26,32)] 
XA15.agg<-aggregate(dane15.lim$XA15, by=list(dane15.lim$wojew_nazwa), sum, na.rm=TRUE)
XA21.agg<-aggregate(dane15.lim$XA21, by=list(dane15.lim$wojew_nazwa), mean, na.rm=TRUE)
dane.agg<-cbind(XA15.agg, XA21.agg$x)
rownames(dane.agg)<-as.character(XA15.agg$Group.1)
colnames(dane.agg)<-c("woj", "XA15", "XA21")
head(dane.agg)

#2.2 Tworzenie, sprawdzanie i konwersja klas przestrzennych

firmy<-read.csv("geoloc data.csv", header=TRUE, dec=",", sep=";")
firmy.lim<-firmy[, c(12,13,20)]
head(firmy.lim)

# podział zbioru na podzbiory wg zmiennej zatr
firmy.5<-firmy.lim[firmy.lim$zatr==5,]
firmy.30<-firmy.lim[firmy.lim$zatr==30,]
firmy.150<-firmy.lim[firmy.lim$zatr==150,]
firmy.600<-firmy.lim[firmy.lim$zatr==600,]
firmy.1500<-firmy.lim[firmy.lim$zatr==1500,]
firmy.5lim<-firmy.5[1:500,] # ograniczenie podzbioru

# połączenie podzbiorów wierszami w jeden zbiór
firmy.f<-rbind(firmy.5lim, firmy.30, firmy.150, firmy.600, firmy.1500)
names(firmy.f)
colnames(firmy.f)<-c("x","y","z") # zmiana nazw kolumn

class(firmy.f)

coordinates(firmy.f)<-c("x","y") # zmiana klasy obiektu
class(firmy.f)
proj4string(firmy.f)
proj4string(firmy.f)<-"+proj=longlat +datum=WGS84 +ellps=WGS84"

# koordynaty planarne
firmy.f.merc<-spTransform(firmy.f, CRS("+proj=merc +ellps=GRS80"))
 
# koordynaty sferyczne
firmy.f.longlat<-spTransform(firmy.f, CRS("+proj=longlat +datum=WGS84 +ellps=WGS84")) 
   
# wykres punktów planarnych
plot(firmy.f.merc)
degAxis(1)
degAxis(2)

# wykres punktów sferycznych
plot(firmy.f.longlat, cex= firmy.f.longlat$z/500, pch=1)
plot(woj[woj@data$jpt_nazwa_=="lubelskie",], add=TRUE)
degAxis(1)
degAxis(2)

# tworzenie SpatialPointsDataFrame
x<-c(5,6,7,8,8,7,6,5,4,3,2,2,3,4)
y<-c(2,3,4,5,6,7,7,6,7,7,6,5,4,3)
xy<-SpatialPointsDataFrame(matrix(c(x,y), ncol=2), 
data.frame(ID=seq(1:length(x))),
proj4string=CRS("+proj=longlat +ellps=WGS84 +datum=WGS84"))
plot(xy)
axis(1)
axis(2)

library(quickPlot)
xy.m<-matrix(c(x,y), ncol=2)
xy.from<-xy.m
xy.m<-rbind(xy.m[dim(xy.m)[1],],xy.m) # dodanie extra wiersza
xy.to<-xy.m[-dim(xy.m)[1],] # usunięcie ostatniego wiersza
xy.lines<-sp2sl(xy.to, xy.from) # klasa SpatialLines
class(xy.lines)

plot(xy.lines, lwd=2)
plot(gridlines(xy), lty=3, add = TRUE) # z pakietu sp
axis(1)
axis(2)

library(raster)
xy.poly<-spPolygons(xy.m)
class(xy.poly)

xy.polydf<-SpatialPolygonsDataFrame(xy.poly, data.frame(ID=1, type="A"))
xy.polydf@data

class(xy.polydf)
str(xy.polydf)
slotNames(xy.polydf) # nazwy gniazd
slotNames(xy.polydf@polygons[[1]]) # nazwy slotów w ramach gniazda
xy.polydf@bbox
lapply(xy.polydf@polygons, slot, "ID")
unlist(lapply(reg1@polygons, slot, "ID"))

#2.3 Wybrane palety kolorystyczne 

# generowanie losowych kolorów
a<-rgb(runif(21,0,1), runif(21,0,1), runif(21,0,1))
a
a.dim1<-length(a)
image(1:a.dim1, 1, as.matrix(1:a.dim1), col=a, xlab="grDevices::rgb() / losowe kolory") # pionowe pasy z kolorami

colors() # kilka pierwszych linii nazw kolorów
library(raster)
r<-raster(xmn=0, xmx=22, ymn=0, ymx=30, nrows=30, ncols=22)
r[]<-1:660
plot(r, col=colors()) # komórki (rastry) z kolorami
col2rgb(c("azure", "azure1", "azure2"), alpha=FALSE)
col2rgb(c("#4B424F", "#BFD15C", "#A44845"), alpha=FALSE)

library(RColorBrewer)
display.brewer.all() # wszystkie palety z pakietu, pionowe pasy
display.brewer.pal(11,'Spectral') # wyświetlenie palety
display.brewer.pal(9,'OrRd') # wyświetlenie palety
cols<-brewer.pal(n=5, name="RdBu") # zapisanie wybranych kolorów

library(wesanderson)
cols1<-wes_palette("GrandBudapest1", 4, type="discrete")
cols1 # pionowe pasy kolorystyczne wraz z nazwą
cols2<-wes_palette("GrandBudapest1", 21, type="continuous")
cols2 # pionowe pasy kolorystyczne wraz z nazwą

library(quickPlot)
# paleta z przykładu komendy
a<-divergentColors("darkred", "darkblue", -10, 10, 0, "white")

a.dim1<-length(a)
image(1:a.dim1, 1, as.matrix(1:a.dim1), col=a, xlab="quickPlot::divergentColors() / darkred-darkblue") # pionowe pasy

# inna paleta
a<-divergentColors("chocolate4", "peachpuff4", -10, 10, 0, "white")
a.dim1<-length(a)
image(1:a.dim1, 1, as.matrix(1:a.dim1), col=a, xlab="quickPlot::divergentColors() / chocolate-peachpuff") # pasy kolorów

library(viridis)
library(scales)
viridis.map
col1<-viridis(15, option="D") # domyślne kolory viridis
show_col(col1) # krata 4x4 z kolejnymi kolorami

col2<-viridis(15, option="B") # paleta inferno
show_col(col2) # krata 4x4 z kolejnymi kolorami

library(ggplot2) # rysunek: heksagony rozchodzące się z centrum
ggplot(data.frame(x=rnorm(10000),y =rnorm(10000)), aes(x=x, y=y)) +
  geom_hex() + coord_fixed() +  scale_fill_viridis() + theme_bw() 

# utworzenie zbioru danych w klasie data.frame
data<-data.frame(x=1:100, y=rnorm(100), z=sample(1:100, 100))
head(data)

# rysunek: wykres punktowy
ggplot(data) +aes(x, y, color=z) +geom_point() +scale_color_viridis_c()

#2.4 Podstawowe mapy konturowe z warstwą kolorystyczną 

# wycztywanie danych powiatowych
dane<-read.csv("dane_pow_2019.csv", header=TRUE, dec=",", sep=";")
summary(dane)

#Schemat 1 – z colorRampPalette() z pakietu grDevices::

library(shape)
zmienna<-dane$XA21[dane$rok==2015]
maxy<-40
breaks<-c(0, 5, 10, 15, 20, 25, 30, 35, 40) # wykorzystane w legendzie 
nclr<-8
plotclr<-brewer.pal(nclr, "Reds") # z pakietu RColorBrewer 
fillRed<-colorRampPalette(plotclr) # z pakietu grDevices  
colcode<-fillRed(maxy)[round(zmienna) + 1] #fillRed jest funkcją 

plot(pow, col=colcode, lty=0) # rys.2.12a 
plot(woj, add=TRUE, lwd=1, border="gray60")  

maps::map.scale(x=18.0, y=49.3, ratio=FALSE, relwidth=0.15, metric=TRUE)
compassRose(16, 49.8,rot=0,cex=1) # z pakietu sp

colorlegend(posy=c(0.05,0.9), posx=c(0.9,0.92), col=fillRed(maxy), zlim=c(0, maxy), zval=breaks, main.cex=0.9) # z pakietu shape

title(main="Stopa bezrobocia w 2015 r.", sub="Na poziomie NTS4, \nwg danych GUS")

#Schemat 2 – z choropleth() z pakietu GISTools::

zmienna<-dane$XA21[dane$rok==2015]
library(GISTools)

choropleth(pow, zmienna) # z pakietu GISTools, rys.2.12b
odcienie<-auto.shading(zmienna)
choro.legend(15, 50, odcienie, cex=0.65, bty="n")

odcienie<-auto.shading(zmienna, n=6, cols=brewer.pal(6, "Purples"))
choropleth(pow, zmienna, shading=odcienie)

# podział na przedziały automatyczny, 
# niższa przezroczystość
odcienie<-auto.shading(zmienna, n=6, cols=add.alpha(brewer.pal(6, "Greens"), 0.5))
choropleth(pow, zmienna, shading=odcienie)
choro.legend(14.3, 50.2, odcienie, under="poniżej", over="powyżej", between="do", cex=0.6, bty="n")

# podział na przedziały wg średniej i odch.std, 
# wyższa przezroczystość
odcienie<-auto.shading(zmienna, n=6, cols=add.alpha(brewer.pal(6, "Greens"),0.35), cutter=sdCuts)
choropleth(pow, zmienna, shading=odcienie)
choro.legend(14.3, 50.2, odcienie, under="poniżej", over="powyżej", between="do", cex=0.6, bty="n")

#Schemat 3 - z findInterval() z pakietu base::
	
zmienna<-dane$wojew_nr[dane$rok==2015]
brks<-(0:16)*2
brks

cols<-c("blue3", "cornflowerblue", "seagreen1", "yellow", "chocolate1", "orangered1", "brown3", "coral4", "salmon4", "aquamarine3", "darkgreen", "chartreuse3", "cyan4", "darkred", "darkviolet", "cadetblue3", "blue")

par(mar=c(1,1,1,1)) # Rys.2.13a
plot(pow, col=cols[findInterval(zmienna, brks)], border="grey80")
plot(woj, add=TRUE, lwd=1)
par(mar=c(5,4,4,2))

# etykiety nazw województw
crds.woj<-coordinates(woj)
woj.df<-as.data.frame(woj)
text(crds.woj, label=woj.df$jpt_nazwa_, cex=0.7, font=2)

zmienna<-dane$wojew_nr[dane$rok==2015]
brks<-(0:16)*2
dens<-(2:length(brks))*3

par(mar=c(1,1,1,1)) # Rys.2.13b
plot(pow, density=dens[findInterval(zmienna, brks, all.inside=TRUE)], border="grey80")
plot(woj, add=TRUE, lwd=1)
par(mar=c(5,4,4,2))

#Schemat 4 - z findColours() z pakietu classInt::

library(classInt)
zmienna<-dane$XA21[dane$rok==2015]
summary(zmienna)

przedziały<-8
kolory<-brewer.pal(przedziały, "BuPu")  # wybór kolorów
klasy<-classIntervals(zmienna, przedziały, style="fixed", 
fixedBreaks=c(0, 5, 10, 15, 20, 25, 30, 35, 40))
tabela.kolorów<-findColours(klasy, kolory) 

plot(pow, col=tabela.kolorów) # rys.2.14a
plot(woj, lwd=2, add=TRUE)
legend("bottomleft", legend=names(attr(tabela.kolorów, "table")), fill=attr(tabela.kolorów, "palette"), cex=0.8, bty="n")
title(main="Stopa bezrobocia w powiatach w 2015 r.")

#Schemat 5 - z spplot() z pakietu sp::

# przygotowanie danych – agregacja i łączenie
dane15.lim<-dane[dane$rok==2015, c(12,21,25)] 
XA15.agg<-aggregate(dane15.lim$XA15, by=list(dane15.lim$wojew_nazwa), sum, na.rm=TRUE)
XA21.agg<-aggregate(dane15.lim$XA21, by=list(dane15.lim$wojew_nazwa), mean, na.rm=TRUE)
dane.agg<-cbind(XA15.agg, XA21.agg$x)
colnames(dane.agg)<-c("woj", "XA15", "XA21")
dane.agg$woj<-tolower(dane.agg$woj) # zmiana wielkości liter na małe

# łączenie danych z identyfikatorami z mapy
order<-data.frame(order=woj@data[,6]) # porządek regionów z mapy
woj.set<-merge(order, dane.agg, by.x="order", by.y="woj", sort=FALSE, all.x=TRUE)
rownames(woj.set)<-0:15 # nadanie nazw wierszy

# dołączenie zbioru danych do SpatialPolygonsDataFrame
woj<-SpatialPolygonsDataFrame(woj, woj.set)

# mapa wg ustawień domyślnych
spplot(woj, "XA15", main="Zatrudnienie wg województw")

# mapa ze zmienioną paletą 
library(viridis)
spplot(woj, "XA15", main="Zatrudnienie wg województw", col.regions = rev(viridis(17, option="B")))

# mapa ze zmienioną paletą i ustaloną liczbą przedziałów
library(RColorBrewer)
spplot(woj, "XA15", main="Zatrudnienie wg województw", col.regions = brewer.pal(9, "BuPu"), cuts=7)

# mapa ze zmienioną paletą i ustalonymi wartościami przedziałów
library(classInt) # do ustalenia przedziałów
library(quickPlot) # do ustalenia kolorów
brks<-classIntervals(woj@data$XA15, style="sd")
cols<-divergentColors("darkred", "darkblue", -10, 10, 0, "white")
spplot(woj["XA15"], main="Zatrudnienie wg województw", at=brks$brks, col.regions=cols)

#2.5 Podstawowe operacje i wykresy dla danych punktowych 

#Schemat 1 – z points() z pakietu graphics:: - wyłącznie lokalizacje

# rysunek danych empirycznych, rys.2.15a
plot(woj[woj@data$jpt_nazwa_=="lubelskie",])
points(firmy$coords.x1, firmy$coords.x2, pch=".")

#Schemat 2 – z spplot() z pakietu sp:: - lokalizacje i wartości

firmy.lim1<-firmy[,c("GR_LPRAC", "podreg", "coords.x1", "coords.x2")]
coordinates(firmy.lim1)<-c("coords.x1","coords.x2") # zmiana klasy obiektu
spplot(firmy.lim1) # rys.2.16a
firmy.lim1<-firmy[,c("SEK_PKD7", "coords.x1", "coords.x2")]
coordinates(firmy.lim1)<-c("coords.x1","coords.x2") # zmiana klasy obiektu
spplot(firmy.lim1, key.space="left") # rys.2.16b

# wybrane zmienne: koodynaty x i y, zatrudnienie, sektor
firmy.sel<-firmy[1:2000,c(12,13,20,18)]
colnames(firmy.sel)<-c("x","y","zatr","sektor") # zmiana nazw zmiennych
coordinates(firmy.sel)<-c("x","y") # zmiana klasy obiektu

par(mar=c(1,1,1,1)) # marginesy wykresu, rys.2.15b
plot(firmy.sel, pch=1, cex=sqrt(firmy.sel$zatr)/3, axes=TRUE)
v<-c(5,30,150,600) # skala legendy
legend("topleft", legend=v, pch=1, pt.cex=sqrt(v)/10, bty="n")
plot(woj[woj@data$jpt_nazwa_=="lubelskie",], add=TRUE, lwd=2)
par(mar=c(5,4,4,2))

#Schemat 3 – z findInterval() z pakietu base:: - lokalizacje, wartości, różna wielkość symboli

zmienna<-firmy$podreg
locs<-firmy[,12:13]
summary(zmienna)
brks<-c(1, 2, 3, 4)
cols<-c("blue3", "cornflowerblue", "seagreen1", "green2")

plot(woj) # rys.2.17a
points(locs, col=cols[findInterval(zmienna, brks)], pch=21, cex=0.7, 
bg=cols[findInterval(zmienna, brks)])
legend("bottomleft", legend=brks, fill=cols, cex=0.8, bty="n")
title(main="Punkty – kolor wg wartości")

lub.woj<-woj[woj.df$jpt_nazwa_=="lubelskie", ] # rys.2.17b
plot(lub.woj)
points(locs, col=cols[findInterval(zmienna, brks)], pch=21, cex=0.7, 
bg=cols[findInterval(zmienna, brks)])
legend("bottomleft", legend=brks, fill=cols, cex=0.8, bty="n")
title(main="Punkty – kolor wg wartości")

savePlot(filename="lokalizacje i wartości losowe", type="jpg")

zmienna<-dane$XA14[dane$rok==2015]
summary(zmienna)
crds<-coordinates(pow)
brks<-c(60, 80, 100, 120, 140, 160, 180)
size<-(brks/100)*1.2
cols=brewer.pal(7, "Reds")

plot(pow, border="grey90") # rys.2.18a
plot(woj, border="grey50", add=TRUE,)
points(crds, col=cols[findInterval(zmienna, brks)], 
cex=size[findInterval(zmienna, brks)], pch=21, bg=cols[findInterval(zmienna, brks)])
legend("bottomleft", legend=brks, pt.bg=cols, pt.cex=size, bty="n", pch=21)
title(main="Średnia płaca w ujęciu Polska=100%
rok 2015", sub="W legendzie przedział od …")
savePlot(filename="Średnia płaca", type="jpg")

dane15<-dane[dane$rok==2015,]
dane.lub<-dane[dane$wojew_nazwa=="Lubelskie",]
dane.lub$powiat_nazwa1

pow.sel<-pow[dane15$powiat_nazwa1=="Powiat Lublin",]
firmy.sp<-firmy
coordinates(firmy.sp)<-c("coords.x1","coords.x2") # zmiana klasy obiektu
proj4string(firmy.sp)<-CRS("+proj=longlat +datum=NAD83")
pow.sel<-spTransform(pow.sel, CRS("+proj=longlat +datum=NAD83"))
firmy.sp<-spTransform(firmy.sp, CRS("+proj=longlat +datum=NAD83"))

# sposób z over()
locs.lim<-over(firmy.sp, pow.sel)

par(mar=c(1,1,1,1))
plot(woj[woj.df$jpt_nazwa_=="lubelskie",])# rysunek – całe województwo
locs<-firmy[,12:13] # wszystkie punkty klasa data.frame
points(locs, col="grey80", pch=".", cex=0.7) # rysunek - wszystkie punkty
points(locs[locs.lim$jpt_nazwa_=="powiat Lublin",], pch=".", cex=1.1)
plot(pow.sel, add=TRUE, border="red") # rysunek – wybrany powiat
par(mar=c(5,4,4,2))

# sposób z gIntersects(), rys.2.18b
library(rgeos)
locs.lim<-gIntersects(pow.sel, firmy.sp, byid=T)

par(mar=c(1,1,1,1))
plot(woj[woj.df$jpt_nazwa_=="lubelskie",])# rysunek – całe województwo
locs<-firmy[,12:13] # wszystkie punkty klasa data.frame
points(locs, col="grey80", pch=".", cex=0.7) # rysunek - wszystkie punkty
points(locs[locs.lim==TRUE,], pch=".", cex=1.1)
plot(pow.sel, add=TRUE, border="red") # rysunek – wybrany powiat
par(mar=c(5,4,4,2))

#2.6 Podstawowe operacje na rastrach

# przygotowanie danych w oparciu o poprzedni przykład
firmy.Lublin<-firmy[firmy$MIEJSOWOS=="Lublin",] 	# firmy w Lublinie
pow.Lublin<-pow.sel				      # mapa konturowa Lublina
par(mar=c(1,1,1,1))
plot(pow.Lublin) # rys.2.19a
points(firmy.Lublin[,12:13], pch=".", cex=1.5)
par(mar=c(5,4,4,2))

bbox(pow.Lublin)

# utworzenie rastra
library(raster)
x1<-firmy.Lublin[,12]	# współrzędne x
y1<-firmy.Lublin[,13]	# współrzędne y
xy1<-cbind(x1,y1)
p1<-data.frame(xy1, z=firmy.Lublin[,20]) # koordynaty i zatrudnienie
r<-raster(nrows=50, ncols=50, ymn=51.14, ymx=51.30, xmn=22.45, xmx=22.67)
r1<-rasterize(xy1, r, field=p1$z, fun=sum)

proj.map<-crs(pow.Lublin) # zbadanie projekcji mapy
proj.map

proj.raster<-crs(r1) # zbadanie projekcji rastra
proj.raster

crs(r1)<-proj.map # zmiana projekcji rastra na projekcję mapy
crs(r1)

plot(r1, main="Zatrudnienie w firmach") # rys.2.19b
plot(pow.Lublin, add=TRUE)

class(r)
class(r1)

# tworzenie rastra na 10’000 kratek
r<-raster(ncols=100, nrows=100, ymn=-50, ymx=50, xmn=-50, xmx=50)

ncell(r)

# liczby całkowite, przypisanie wartości do rastra
r[]<-round(runif(ncell(r), 1,8), digits=0) 
plot(r) # rysunek grid / komórek w losowych kolorach

r1<-r^2
plot(r1) # rysunek grid / komórek w losowych kolorach

vals<-extract(r, 1:ncell(r))
head(vals)

table(firmy.Lublin$SEK_PKD7)
firmy.Lublin$ones<-rep(1, times=dim(firmy.Lublin)[1])
firmy.LublinG<-firmy.Lublin[firmy.Lublin$SEK_PKD7=="G",]
firmy.LublinA<-firmy.Lublin[firmy.Lublin$SEK_PKD7=="A",]

r<-raster(nrows=50, ncols=50, ymn=51.14, ymx=51.30, xmn=22.45, xmx=22.67)

x1<-firmy.LublinG[,12] # lokalizacja firm - koordynaty x
y1<-firmy.LublinG[,13] # lokalizacja firm - koordynaty y
xy1<-cbind(x1,y1) # koordynaty x i y jako data.frame
p1<-data.frame(xy1, z=firmy.LublinG$ones) 	#liczba firm - sektor G
r1<-rasterize(xy1, r, field=p1$z, fun=sum)

x2<-firmy.LublinA[,12]
y2<-firmy.LublinA[,13]
xy2<-cbind(x2,y2)
p2<-data.frame(xy2, z=firmy.LublinA$ones) 	#liczba firm sektor A
r2<-rasterize(xy2, r, field=p2$z, fun=sum)

plot(r1, col=colorRampPalette(c("cornsilk2", "indianred1", "brown3"))(255), main="Rozkład firmy z sektora G")
plot(pow.Lublin, add=TRUE) # rys.2 20a

plot(r2, col=colorRampPalette(c("cornsilk2", "indianred1", "brown3"))(255), main="Rozkład firmy z sektora A")
plot(pow.Lublin, add=TRUE)

# korelacja Pearsona
cor.r<-corLocal(r1, r2, ngb=5, method="pearson", test=TRUE) 
summary(cor.r)

# wykres statystyki Pearsona, rys.2.20b
plot(cor.r$pearson, main="korelacja liczby firm z sektorów G i A")
plot(pow.Lublin, add=TRUE)

# wykres p-value
plot(cor.r$p.value, main="p-value korelacji liczby firm z sektorów G i A ")
plot(pow.Lublin, add=TRUE)

ct<-crosstab(r1, r2) 
head(ct)

# raster i wykres istotnych różnic
library(SDMTools)
out<-SigDiff(r1,r2, pattern=FALSE)
out.val<-extract(out, 1:ncell(out))

proj.map<-crs(pow.Lublin) # zbadanie projekcji mapy
proj.raster<-crs(out) # zbadanie projekcji rastra
crs(out)<-proj.map # zmiana projekcji rastra na projekcję mapy

# rysunek w oparciu o ImageDiff()
plot(pow.Lublin)
ImageDiff(out, main="Pattern Differences", axes=FALSE, 
tcol=c("indianred1","cornsilk2","palegreen1"), add=TRUE) 

legend('bottomright', title='significance', 
legend=c('lower','greater','not significant'), fill=c("indianred1","palegreen1","cornsilk2"),bg='white', bty='n')

# rysunek w oparciu o plot()
plot(pow.Lublin)
plot(out, add=TRUE)
cols<- rev(terrain.colors(12))
legend('bottomright', title='significance', 
legend=c('lower', 'not significant', 'greater'), fill=c(cols[1], cols[6], cols[12]), bg='white', bty='n', cex=0.8)

# raster skonwertowany do klasy SpatialPointsDataFrame, rys.2.22a
r1p<-rasterToPoints(r1, spatial=TRUE)
r2p<-rasterToPoints(r2, spatial=TRUE)
plot(r1p, pch=21, bg="red", ylim=c(51.14,51.3))
points(r2p, pch=21, bg="yellow", cex=0.8)
plot(pow.Lublin, add=TRUE)
degAxis(1)
degAxis(2)

# raster skonwertowany do klasy matrix, rys.2.22b
r1p<-rasterToPoints(r1)
r2p<-rasterToPoints(r2)
plot(r1p, pch=21, bg="red", ylim=c(51.14,51.3), xlim=c(22.45, 22.67))
points(r2p, pch=21, bg="yellow", cex=0.8)
plot(pow.Lublin, add=TRUE)

# konwersja rastra do wieloboków i macierzy W
library(spdep)
r1.poly<-rasterToPolygons(r1, na.rm=FALSE)
r1p.nb<-poly2nb(r1.poly)
r1p.listw<-nb2listw(r1p.nb)
r1.df<-as.data.frame(r1, na.rm=FALSE, xy=FALSE)
summary(r1.df)
r1.df<-as.data.frame(r1, na.rm=FALSE, xy=TRUE)
summary(r1.df)

#2.7 Podstawowe operacje na gridach

#ładowanie świeżych obiektów
woj<-readOGR(".", "wojewodztwa") # 16 jedn. 
woj<- spTransform(woj, CRS("+proj=longlat +datum=NAD83"))

# utworzenie wycinka mapy – województwo (NTS2) Lubelskie
woj.df<-as.data.frame(woj) 
lub.woj<-woj[woj.df$jpt_nazwa_=="lubelskie", ] 

grid.lub<-makegrid(lub.woj, n=100)  # siatka w ramach bouding box

plot(grid.lub)# wynik planarny, rys.2.23a
plot(lub.woj, add=TRUE) # warstwa sferyczna

plot(lub.woj)	# warstwa sferyczna, rys.2.23b
points(grid.lub, pch=".", cex=1.5) # wynik planarny

# sferyczny grid
grid.lub.sp<-SpatialPoints(grid.lub, proj4string=CRS(proj4string(lub.woj)))

plot(grid.lub.sp) # warstwa 1: grid, warstwa 2: kontur
plot(lub.woj, add=TRUE)

plot(lub.woj) # warstwa 1: kontur, warstwa 2: grid
plot(grid.lub.sp, add=TRUE)

grid.limited<-grid.lub.sp[lub.woj, ]
plot(lub.woj) # grid zawężony do konturu regionu
plot(grid.limited, add=TRUE)

# wczytywanie grid dla populacji i konwersja projekcji
pop<-readOGR(".", "PD_STAT_GRID_CELL_2011")
pop<-spTransform(pop, CRS("+proj=longlat +datum=NAD83"))

pop.df<-as.data.frame(pop) # wyodrębnienie danych do obiektu data.frame
head(pop.df)
pop.grid<-as(pop, "SpatialPolygons") # wyodrębnienie grid

str(pop) # sprawdzenie struktury slotów i gniazd
summary(pop@data$FEM_RATIO) # podsumowanie wybranej zmiennej

# konwersja na dane liczbowe kolejnych kolumn zbioru danych
for(i in 1:15){ # nie działa dla wszystkich zmiennych
pop.df[,i]<-as.numeric(levels(pop.df[,i]))[pop.df[,1]]}

# ucięcie mapy konturowej
pow.lub<-pow[pow@data$jpt_nazwa_=="powiat Lublin",]

lim<-over(pop.grid, pow.lub) # złożenie grid i mapy konturowej
head(lim[,1:7]) # obiekt klasy data.frame
a<-which(lim$jpt_nazwa_=="powiat Lublin") # wiersze spełniające warunek
head(lim[a,1:7])

# warunkowe ograniczenie grid i data.frame do wybranego terenu
pop.grid.lub<-pop.grid[lim$jpt_nazwa_=="powiat Lublin", ]
pop.df.lub<-pop.df[a, ]

# Rys.2.24a – kontur administracyjny i grid
plot(pop.grid.lub)
plot(pow.lub, add=TRUE)

# Rys.2.24b – wartości badanej zmiennej
library(GISTools)
choropleth(pop.grid.lub, pop.df.lub$TOT)
plot(pow.lub, add=TRUE)

library(raster)
names(firmy)

# wybrane zmienne: koordynaty x i y, zatrudnienie, sektor
firmy.sel<-firmy[,c(12,13,20,18)]
colnames(firmy.sel)<-c("x","y","zatr","sektor") # zmiana nazw zmiennych
coordinates(firmy.sel)<-c("x","y") # zmiana klasy obiektu na SpatialPoints

pop.grid.lub$ID<-rownames(pop.df.lub) # identyfikator jednostek w grid
pop.df.lub$ID<-rownames(pop.df.lub) # indentyfikator jednostek w data.frame
crs(firmy.sel)<-crs(pop.grid.lub) # uzgodnienie projekcji

firmy.sel$ID<-over(firmy.sel, pop.grid.lub) # przypisanie ID grid do firm
head(firmy.sel)
summary(firmy.sel)

crds<-coordinates(pop.grid.lub) 	# centroidy komórek grid
plot(pop.grid.lub)			# wykres grid
#text(crds, labels=pop.grid.lub$ID, cex=0.4)
library(maptools)
pointLabel(crds, labels=pop.grid.lub$ID, cex=0.4)

# zmiana klasy obiektu
firmy.sel.df<-as.data.frame(firmy.sel)
head(firmy.sel.df)

# agregacja danych punktowych wg ID zbioru grid 
# statystyki – liczba obserwacji i suma zatrudnionych
firmy.agg.no<-aggregate(firmy.sel.df$ID, by=list(firmy.sel.df$ID), length)
firmy.agg.sum<-aggregate(firmy.sel.df$zatr, by=list(firmy.sel.df$ID), sum)
head(firmy.agg.no)

# łączenie zbiorów przez wyszukiwanie
pop.df.lub.m<-merge(pop.df.lub, firmy.agg.no, by.x="ID", by.y="Group.1", all.x=TRUE)
pop.df.lub.m<-merge(pop.df.lub.m, firmy.agg.sum, by.x="ID", by.y="Group.1", all.x=TRUE)
names(pop.df.lub.m)

m1<-which(is.na(pop.df.lub.m$x.x)) # rys.2.25a
pop.df.lub.m$x.x[m1]<-0
choropleth(pop.grid.lub, pop.df.lub.m$x.x) # liczba firm
title(main="Liczba firm w grid")
odcienie<-auto.shading(pop.df.lub.m$x.x)
choro.legend(22.65, 51.2, odcienie, cex=0.65, bty="n")

m2<-which(is.na(pop.df.lub.m$x.y))
pop.df.lub.m$x.y[m2]<-0
choropleth(pop.grid.lub, pop.df.lub.m$x.y) # suma zatrudnienia w firmach
title(main="Łączne zatrudnienie w firmach w grid")
odcienie<-auto.shading(pop.df.lub.m$x.y)
choro.legend(22.65, 51.2, odcienie, cex=0.65, bty="n")

levels(firmy.sel$sektor)
head(firmy.sel)
sektors<-LETTERS[seq(from=1, to=19)]
sektors

for(i in 1:19){
sub<-firmy.sel.df[firmy.sel.df$sektor==sektors[i],]
sub.agg<-aggregate(sub$ID, by=list(sub$ID), length)
pop.df.lub.m<-merge(pop.df.lub.m, sub.agg, by.x="ID", by.y="Group.1", all.x=TRUE)
colnames(pop.df.lub.m)[19+i]<-paste("Sektor", sektors[i], sep="_")}

pop.df.lub.m$count<-(19-rowSums(is.na(pop.df.lub.m[,20:38])))
head(pop.df.lub.m)[,20:39]

library(classInt)
zmienna<-pop.df.lub.m$count
przedziały<-9
kolory<-brewer.pal(9, "BuPu")  # wybór kolorów
klasy<-classIntervals(zmienna, przedziały, style="fixed", 
fixedBreaks=c(0, 2, 4, 6, 8, 10, 12, 14, 16, 18))
tabela.kolorów<-findColours(klasy, kolory) 

plot(pop.grid.lub, col=tabela.kolorów) # rys.2.25b
plot(pow.lub, add=TRUE)

legend("bottomleft", legend=names(attr(tabela.kolorów, "table")), fill=attr(tabela.kolorów, "palette"), cex=0.8, bty="n")
title(main="Liczba sektorów reprezentowanych przez firmy 
w ramach grid")

#2.8 Geometrie przestrzenne

# wybrane zmienne: koordynaty x i y, zatrudnienie, sektor
firmy.sel<-firmy[,c(12,13,20,18)]
colnames(firmy.sel)<-c("x","y","zatr","sektor") # zmiana nazw zmiennych
firmy.sel$x<-jitter(firmy.sel$x) # rozrzut koordynat x o epsilon
firmy.sel$y<-jitter(firmy.sel$y) # rozrzut koordynat y o epsilon
coordinates(firmy.sel)<-c("x","y") # zmiana klasy obiektu na SpatialPoints
library(rgeos)
tri.full<-gDelaunayTriangulation(firmy.sel) # traingulacja
tri.lim<-gDelaunayTriangulation(firmy.sel[1:1000,])

plot(tri.full) #Rys.2.26a
plot(tri.lim) #Rys.2.26b
points(firmy.sel[1:1000,], col="red", pch=".", cex=3)

# wybrane zmienne: koordynaty x i y, zatrudnienie, sektor
firmy.sel<-firmy[1:2000,c(12,13,20,18)]
colnames(firmy.sel)<-c("x","y","zatr","sektor") # zmiana nazw zmiennych
firmy.sel$x<-jitter(firmy.sel$x) # rozrzut koordynat x o epsilon
firmy.sel$y<-jitter(firmy.sel$y) # rozrzut koordynat y o epsilon

# przygotowanie danych punktowych w różnych klasach
# wymagane do gBuffer() – koordynaty planarne
xy<-cbind(firmy.sel$x, firmy.sel$y)
xy.sp<-SpatialPoints(xy) 

# wymagane do over() – koordynaty sferyczne
firmy.sp<-firmy.sel
coordinates(firmy.sp)<-c("x","y")
projekcja<-"+proj=longlat +datum=WGS84"
proj4string(firmy.sp)<-projekcja
firmy.sp<-spTransform(firmy.sp, CRS("+proj=longlat +datum=NAD83"))

# tworzenie okregów i sprawdzanie przynależności punktów do okręgu
imax<-2000 # dla 2000 obserwacji
firmy.sel[,5]<-NA # tworzenie pustej kolumny
library(rgeos)
for(i in 1:imax){
ring<-gBuffer(xy.sp[i,], quadsegs=50, byid=TRUE, width=0.1) #okrąg z punktu
proj4string(ring)<-CRS("+proj=longlat +datum=NAD83")
ring<-spTransform(ring, CRS("+proj=longlat +datum=NAD83"))
firmy.sel[,i+5]<-over(firmy.sp, ring) # przynależność pkt do okręgu
firmy.sel[i,5]<-sum(firmy.sel$zatr*firmy.sel[,i+5], na.rm=TRUE) / sum(firmy.sel[,i+5], na.rm=TRUE) #średnie zatrudnienie u sąsiadów
}

# wykres liczby zatrudnionych w pkt vs. u sąsiadów
plot(firmy.sel$zatr[1:imax], firmy.sel[1:imax,5]) # Rys.2.27a

# ilu sąsiadów wokół danego punktu
# liczone jako sumy kolejnych kolumn
firmy.sel$firms.around<-apply(firmy.sel[,6:2005], 2, sum, na.rm=TRUE)

# wykres liczby sąsiadów w pobliżu – Rys.2.27b
firmy.sel1<-firmy.sel[,c("x", "y", "firms.around")]
coordinates(firmy.sel1)<-c("x","y") # zmiana klasy obiektu

spplot(firmy.sel1, key.space="bottom", sp.layout=list(woj[woj@data$jpt_nazwa_=="lubelskie",], col='grey'))

pow<-readOGR(".", "powiaty") # 16 jedn. 
pow<- spTransform(pow, CRS("+proj=longlat +datum=NAD83"))

pow.lub<-pow[pow@data$jpt_nazwa_=="powiat Lublin",]
pkt.lub<-spsample(pow.lub, 100, type="random")

radius<-rnorm(100, mean=0.007, sd=0.003)
xy<-cbind(pkt.lub@coords[,1], pkt.lub@coords[,2]) 
xy.sp<-SpatialPoints(xy) # wymagane do gBuffer
circles<-gBuffer(xy.sp, quadsegs=50, byid=TRUE, width=radius)

plot(pow.lub, lwd=2) # Rys.2.28a
points(pkt.lub, pch=".", cex=2) 
plot(circles, add=TRUE)

# union (część wspólna) nakładających się okręgów 
circles.union<-gUnaryUnion(circles) # z pakietu rgeos
plot(pow.lub, lwd=2) # Rys.2.28b
plot(circles.union, add=TRUE)

gArea(circles)
gArea(circles.union)
gArea(pow.lub)

