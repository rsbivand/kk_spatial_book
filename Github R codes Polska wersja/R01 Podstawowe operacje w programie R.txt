##############################################
#Przestrzenne metody ilościowe w R: statystyka, ekonometria, uczenie maszynowe, analiza danych
#Redakcja Katarzyna Kopczewska
#Autorzy: Katarzyna Kopczewska, Maria Kubara, Piotr Ćwiakowski, Mateusz Kopyt, Piotr Wójcik, Alessandro Festi, Kateryna Zabarina
#Warszawa, 2020, CeDeWu
#Wydanie książki zostało sfinansowane z grantu Narodowego Centrum Nauki (NCN) pt. Modele ekonometryczne przestrzenne ze stałą i zmienną strukturą sąsiedztwa. Zastosowanie do wyceny nieruchomości i lokalizacji firm (OPUS 12, umowa nr UMO-2016/23/B/HS4/02363).
#Książka została wydana w angielskiej wersji językowej jako: Applied Spatial Statistics and Econometrics: Data Analysis in R (redakcja Katarzyna Kopczewska, autorzy: Katarzyna Kopczewska, Maria Kubara, Piotr Ćwiakowski, Mateusz Kopyt, Piotr Wójcik, Alessandro Festi, Kateryna Zabarina), Routledge, 2020
##############################################

#Rozdział 1
#Podstawowe operacje w programie R
#Mateusz Kopyt

#1.1 O oprogramowaniu R
#1.2 Interfejs programu R
#1.2.1 R Commander
#1.2.2. RStudio
#1.3 Korzystanie z pomocy

?cor
help("cor")

?? correlation
help.search("correlation")

apropos("cor")
 
library(help="stats")

example("cor")

help.start()

demo(colors) # pokazuje dostępne kolory i ich nazwy jako kolorowy tekst

#1.4 Pakiety dodatkowe

search()
update.packages()
library("spdep")

requiredPackages <- c("sp", "spdep", "RColorBrewer") # przykładowa lista pakietów
for(i in requiredPackages){
  if(!require(i,character.only = TRUE)) install.packages(i)
  library(i,character.only = TRUE) }

detach("package:spdep", unload=TRUE)

#1.5 Język programu R - podstawowe cechy
#1.6 Definiowanie i wczytywanie danych

getwd() #sprawdzenie bieżącego katalogu roboczego
setwd("C:/R/Dane/") #ustawienie żądanego katalogu roboczego – przykład
library(foreign) # biblioteka obsługująca dodatkowe formaty plików
getwd() # sprawdza lokalizację katalogu domyślnego

# wczytywanie z pliku tekstowego
dane1<-read.table("dane.txt", header=TRUE, sep="\t", encoding="UTF-8") 

# wczytywanie z pliku CSV
dane2<-read.csv("dane.csv",header=TRUE, sep=";",dec=".", encoding="UTF-8")

# wczytywanie z pliku rozdzielanego tabulacją
dane3<-read.delim("dane.dat", header=FALSE, sep="\t") 

# wczytywanie z pliku dbf
dane4<-read.dbf("dane.dbf") 

# wczytywanie z formatu SPSS
dane5<-read.spss("dane.sav", use.value.labels=FALSE, to.data.frame=TRUE) 

# wczytywanie z formatu STATA
dane6<-read.dta("dane.dta", convert.factors=FALSE) 

library(gdata)
dane7 = read.xls ("myfile.xlsx", sheet = 1, header = TRUE)

#1.7 Podstawowe operacje na obiektach

3+5

wektor1<-c(1,2,3,4,5) # wektor liczb 1,2,3,4,5
wektor2<-10:20 # wektor liczb całkowitych od 10 do 20
wektor3<-seq(5,10,0.2) # sekwencja liczb od 5 do 10 z krokiem 0,2

dane<-read.csv("Dane/dataset2s.csv", header=TRUE, sep=";", dec=",", encoding="UTF-8")

names(dane)

class(dane)

str(dane) # struktura obiektu
attributes(dane) # atrybuty obiektu

wektor3<-seq(5,10,0.2) # przypomnienie wektora
nowy_wektor3<-wektor3 # przypisanie do nowej nazwy
nowy_wektor3 # wyświetlenie obiektu
rm(wektor3) # wykasowanie z pamięci obiektu wektor3

x<-seq(1, 20, 0.4) # generowanie zmiennej x
y<-seq(2,21,0.4)  # generowanie zmiennej y
z<-seq(3,22,0.4)  # generowanie zmiennej z
xyz<-cbind(x,y,z)  # łączenie zmiennych w jeden obiekt xyz 

head(xyz) # wyświetlenie początku obiektu xyz
names(xyz)  # żądanie wyświetlenia nagłówków

colnames(xyz)<-c("zmienna x", "zmienna y", "zmienna z") # nowe nazwy kolumn
rownames(xyz)<-rownames(xyz, do.NULL = FALSE, prefix = "Obs.") # nowe nazwy wierszy

is.data.frame(xyz)  # sprawdzenie czy xyz jest obiektem klasy data.frame
xyz.df<-as.data.frame(xyz)  # konwersja xyz na data frame	

head(xyz.df)  # wyświetlenie obiektu xyz po zmianach
names(xyz.df)  # żądanie wyświetlenia nagłówków kolumn
colnames(xyz.df)  # żądanie wyświetlenia nagłówków kolumn
rownames(xyz.df)  # żądanie wyświetlenia nagłówków wierszy

bezrob<-dane$XA06
head(bezrob)
wycinek<-dane[1:10, 3:5] # obserwacje od 1 do 10 ze zmiennymi z kolumn 3 do 5
wycinek

# tylko wiersze 2,7,10,15 i wszystkie kolumny
wycinek2<-dane[c(2,7,10,15), ]

# wiersze 1 do 10, ale bez wybranej kolumny - tu piątej 
# znak (-) usuwa dany wiersz lub kolumnę z wyniku
wycinek3<-dane[1:10,-5] 

dane15<-dane[dane$rok==2015,]
head(dane15)

podkarp.lub.opol<-dane15[dane15$województwo=="Opolskie" | dane15$województwo=="Podkarpackie", ]

# połączenie kilku zmiennych w jeden obiekt
zatrudnienie<-cbind(dane15$XA03, dane15$XA04, dane15$XA05) 

# ograniczenie zbioru dla zwiększenia przejrzystości
zatrudnienie<-as.data.frame(zatrudnienie[1:6, ]) 

# nadanie nowych nagłówków
colnames(zatrudnienie)<-c("rolnictwo", "przemysł", "usługi") 

# wyświetlenie zawartości obiektu
zatrudnienie

# nowy obiekt zawierający znacznik (ind) oraz wartości  
zat.stack<-stack(zatrudnienie) zat.stack # wyświetlenie zawartości obiektu po funkcji stack()

unstack(zat.stack) # powrót do pierwotnych danych
dane15$XA17a<-dane15$XA17 # utworzenie kopii zmiennej XA17, nowa nazwa XA17a

# stworzenie obserwacji brakujących kodowanych jako 99999
dane15$XA17a[c(3,5,9,10)]<-99999 

head(dane15$XA17a,12) # wyświetlenie pierwszych 12 danych zmiennej XA17a

# przyporządkowanie NA obserwacjom brakującymis.na(dane15$XA17a)<-dane15$XA17a>=99998 

# ponowne wyświetlenie pierwszych 12 danych zmiennej XA17a
head(dane15$XA17a,12) 

#1.8 Podstawowe statystyki zbioru danych

summary(dane15)

zatrudnienie<-as.data.frame(cbind(dane15$XA03, dane15$XA04, dane15$XA05))
colnames(zatrudnienie)<-c("rolnictwo", "przemysł", "usługi") 

# średnia ze wszystkich zmiennych obiektu data.frame za pomocą lapply()
lapply(zatrudnienie,mean,na.rm=T)

# średnia ze wszystkich zmiennych obiektu data.frame za pomocą sapply()
sapply(zatrudnienie,mean,na.rm=T) 

# średnia z jednej zmiennej (kolumny) z obiekty klasy data.frame
mean(zatrudnienie$usługi, na.rm=TRUE)

var1<-rnorm(1000) # losowane 1000 liczb z rozkładu normalnego
quantile(var1)

# określenie progów prawdopodobieństwa przez użytkownika
quantile(var1,  probs=c(1,2,5,95,98,99)/100) 

fivenum(dane15$XA06) # statystyki pozycyjne dla wybranej zmiennej
class(dane$województwo) # sprawdzenie czy wybrana zmienna jest typu faktor
levels(dane$województwo) # nazwy klas / poziomów
nlevels(dane$województwo)  # liczba klas / poziomów
cor(dane15$XA06,dane15$XA30)
cor.test(dane15$XA06,dane15$XA30)

# pracujący per capita - liczba pracujących podzielona przez ludność ogółem
# nowa zmienna prac.pc dodana do obiektu dane15
dane15$prac.pc<-dane15$XA02/(dane15$XA19+dane15$XA20+dane15$XA21)

# stworzenie nowego obiekty zawierającego tylko zmienne: 
# stopa bezrobocia, wynagrodzenie, pracujący per capita
zmienne.df<-data.frame(cbind(dane15$XA06, dane15$XA30, dane15$prac.pc))
colnames(zmienne.df)<-c("stopa bezrobocia ", "wynagrodzenia", "pracujący per capita")

# macierz korelacji, zastosowano funkcję zaokrąglającą wyniki 
# do dwóch miejsc po przecinku dla zwiększenia czytelności
round(cor(zmienne.df, use="pairwise"),2)

# wykres korelacji
pairs(zmienne.df) 
zmienna<-dane15$XA30

# wyrażenie standaryzyjące zmienną - nowa zmienna to Z_zmienna
Z_zmienna<-(zmienna-mean(zmienna))/sd(zmienna)

# średnia zmiennej standaryzowanej jest bardzo bliska wartości zero
mean(Z_zmienna)
# wariancja jest równa 1
var(Z_zmienna)

zmienna1<-dane15$XA30
Z_zmienna1<-scale(zmienna1) # zmienna wystandaryzowana
mean(Z_zmienna1)
var(Z_zmienna1)

#1.9 Wizualizacja - podstawy
#1.9.1 Wykres punktowy oraz liniowy

dane<-read.csv("Dane/dataset2s.csv", header=TRUE, sep=";", dec=",", encoding="UTF-8")

# agregacja danych względem roku
bezrobocie<-aggregate(dane$XA06, by=list(dane$rok), mean, na.rm=TRUE) 
bezrobocie
par(mfrow=c(1,2), mar=c(2,2,2,1))
plot(bezrobocie$x) #najprostszy wykres punktowy

#wykres liniowy z opcjami dodatkowymi
plot(bezrobocie$x, type= "l", lwd=2, axes=FALSE, xlab="rok", ylim=c(10,20))
axis(1, at=1:10, labels=bezrobocie$Group.1, cex=0.8)
axis(2)
abline(h=(5:10)*2, lty=3)
abline(v=(1:10)*1, lty=3)
points(bezrobocie$x, pch=21, bg="red", cex=1.5)
title(main="Średnia stopa bezrobocia w Polsce
      na podstawie danych powiatowych", cex.main=0.8)
legend(3,20, pch=21, pt.bg="red", col="black", lwd=2, c("stopa bezrobocia"), bty="n", cex = 0.6)
text(1:10, bezrobocie$x+0.5, round(bezrobocie$x,2), cex=0.6)

x<-seq(1,25,1) # generowanie zmiennej x
y<-2*x^2  # generowanie zmiennej y
# podział obszaru wykresu na części i określenie marginesów
par(mfrow=c(2,3), mar=c(2,2,2,2)) 
plot(y, type="p", main="typ p") # jak plot() bez parametru type=
plot(y, type="l", main="typ l")
plot(y, type="o", main="typ o")
plot(y, type="h", main="typ h")
plot(y, type="s", main="typ s")
plot(y, type="S", main="typ S")

#1.9.2 Wykres kolumnowy

# wczytanie danych 
dane<-read.csv("Dane/dataset2s.csv", header=TRUE, sep=";", dec=",", encoding="UTF-8")

# Rys.1.12a
pprod<-aggregate(dane$XA19, by=list(dane$rok), sum, na.rm=TRUE)
colnames(pprod)<-c("rok","l_pprod")

# opcja names.arg podaje etykiety pod słupkami
barplot(pprod$l_pprod/1000, col="grey", ylim=c(0,8000), ylab="w tys.",
        names.arg = pprod$rok, cex.axis=0.8, main="Ludność w wieku przedprodukcyjnym", cex.names=0.8) 
abline(h=c(6000,7000,8000), lty=3, col="red") # linie pomocnicze

# Rys.1.12b
# wykres słupkowy skumulowany
przprod<-aggregate(dane$XA19, by=list(dane$rok), sum, na.rm=TRUE)
prod<-aggregate(dane$XA20, by=list(dane$rok), sum, na.rm=TRUE)
poprod<-aggregate(dane$XA21, by=list(dane$rok), sum, na.rm=TRUE)
ludnosc<-cbind(przprod, prod$x, poprod$x)
colnames(ludnosc)<-c("rok", "przedpr", "prod", "poprod")

# konwersja obiektu data.frame do matrix do polecenia barplot
ludnosc.m<-as.matrix(ludnosc) 
barplot(t(ludnosc.m[,2:4]/1000), ylim=c(0,40000), names.arg=ludnosc.m[,1], cex.axis=0.8, 
        legend.text=TRUE, args.legend=list(x="right", bg="white"), cex.names=0.8, main="Struktura ludności wg lat")
abline(h=ludnosc.m[1,2]/1000, lty=3, lwd=2, col="blue")
abline(h=sum(ludnosc.m[1,2:3]/1000), lty=3, lwd=2, col="blue")
abline(h=sum(ludnosc.m[1,2:4]/1000), lty=3, lwd=2, col="blue")
t(ludnosc.m[,2:4])

#1.9.3 Wykres kołowy

dane15<-dane[dane$rok==2015,]
struktura<-aggregate(cbind(XA19, XA20, XA21)~województwo, data=dane15, sum)
colnames(struktura)<-c("województwo","Przedpr.","Prod.","Popr.")
struktura_m<-struktura[struktura$województwo=="Mazowieckie",]
struktura_m<-struktura_m[2:4] #usunięcie nazwy województwa

# podział obszaru wykresu na 2 części i określenie marginesów
par(mfrow=c(1,2), mar=c(2,2,2,2))
# przekształacenie obiektu data.frame w wektor numeryczny
pie(as.numeric(struktura_m), labels=names(struktura_m), cex=0.6) 

library(plotrix) # załadowanie wymaganego pakietu
pie3D(as.numeric(struktura_m),edges=1000,radius=1.3,height=0.2,theta=pi/4,start=0, explode=0.20, col=heat.colors(3),labels=names(struktura_m), labelcex=0.7)

#1.9.4 Wykres pudełkowy (boxplot)

dane<-read.csv("Dane/dataset2s.csv", header=TRUE, sep=";", dec=",")
dane15<-dane[dane$rok==2015,]
boxplot(dane15$XA06, col="grey78", ylab="stopa bezrobocia", 
        main="Stopa bezrobocia w powiatach w roku 2015")

a<-aggregate(dane15$XA06, by=list(dane15$województwo), mean, na.rm=TRUE)
a$ID<-c(1:16)
colnames(a)<-c("woj", "x", "ID")
boxplot(dane15$XA06~dane15$województwo, axes=FALSE, ylim=c(0,65), col="bisque", border="bisque4")

# linia średniej stopy bezrobocia
abline(h=mean(dane15$XA06, na.rm=TRUE), lty=3, col="red") 

# osie
axis(1, at=1:16, labels=a$ID, cex.axis=0.8)
axis(2, at=(0:6)*10, cex.axis=0.8, ylab="%")

# tekst legendy
for(i in 1:16){
text(1,60-3.5*i, a$ID[i], cex=0.6)
text(4,60-3.5*i, a$woj[i], cex=0.6)}
for(i in 9:16){
text(8,60-3.5*(i-8), a$ID[i], cex=0.6)
text(11,60-3.5*(i-8), a$woj[i], cex=0.6)}

title(main="Stopa bezrobocia w 2015r. wg województw", 
      sub="Dane zagregowane z poziomu powiatów", cex.main=0.8, cex.sub=0.7)

head(colors(),12)

#1.10 Regresja w przykładach
plot(log(dane15$XA30),dane15$XA06, xlab="Logarytm wynagrodzenia przec. w PLN", ylab="Bezrobocie rejestrowane w %")

model1<-lm(XA06~log(XA30), data=dane15)
model1  # wynik regresji – wersja podstawowa
summary(model1) # wynik regresji – wersja pełna

plot(log(dane15$XA30),dane15$XA06, xlab="Logarytm wynagrodzenia przec. w PLN", ylab="Bezrobocie rejestrowane w %")
abline(model1)
intercept<-model1$coefficients[1]  # wyodrębnienie wyrazu wolnego
slope<-model1$coefficients[2] # wyodrębnienie nachylenia prostej regresji

intercept
slope

par(mfrow=c(1,2)) # opcja umożliwiająca pokazanie dwóch wykresów obok siebie
res<-residuals(model1) 
plot(res, ylab="Reszty") 
abline(h=0, lty=2)  
title(main="Wykres punktowy reszt")

# histogram reszt o 30 przedziałach
hist(res, breaks=30, main="Histogram reszt", freq = FALSE, xlab="Reszty")

# tworzenie funkcji gęstości rozkładu normalnego 
# o parametrach zgodnych z rozkładem empirycznym reszt
mean.res<-mean(res)
sd.res<-sd(res)
x<-seq(min(res), max(res),length=100)
y<-dnorm (x, mean.res, sd.res)
lines(x,y)  # linia teoretycznego rozkładu normalnego

model1.fit<-predict(model1)  # wartości teoretyczne uzyskane z modelu 
blad<-dane15$XA06-model1.fit # błąd jako różnica wartości empirycznych i teoretycznych 

shapiro.test(dane15$XA30) # test normalności rozkładu zmiennej bezrobocie

