##############################################
#Przestrzenne metody ilościowe w R: statystyka, ekonometria, uczenie maszynowe, analiza danych
#Redakcja Katarzyna Kopczewska
#Autorzy: Katarzyna Kopczewska, Maria Kubara, Piotr Ćwiakowski, Mateusz Kopyt, Piotr Wójcik, Alessandro Festi, Kateryna Zabarina
#Warszawa, 2020, CeDeWu
#Wydanie książki zostało sfinansowane z grantu Narodowego Centrum Nauki (NCN) pt. Modele ekonometryczne przestrzenne ze stałą i zmienną strukturą sąsiedztwa. Zastosowanie do wyceny nieruchomości i lokalizacji firm (OPUS 12, umowa nr UMO-2016/23/B/HS4/02363).
#Książka została wydana w angielskiej wersji językowej jako: Applied Spatial Statistics and Econometrics: Data Analysis in R (redakcja Katarzyna Kopczewska, autorzy: Katarzyna Kopczewska, Maria Kubara, Piotr Ćwiakowski, Mateusz Kopyt, Piotr Wójcik, Alessandro Festi, Kateryna Zabarina), Routledge, 2020
##############################################

#Rozdział 4
#Macierze wag przestrzennych, pomiar odległości, teselacja, statystyka przestrzenna
#Katarzyna Kopczewska, Maria Kubara

#4.1. Wprowadzenie do analizy danych przestrzennych
#4.2 Macierze wag przestrzennych
#4.2.1 Ogólne ramy tworzenia macierzy wag przestrzennych
#4.2.2 Wybór macierzy sąsiedztwa
#4.2.3 Macierze sąsiedztwa według kryterium wspólnej granicy

# ładowanie pakietów
library(rgdal) 
library(spdep)

#mapa powiatowa
pow<-readOGR(".", "powiaty") # 380 jedn. 
pow<-spTransform(pow, CRS("+proj=longlat +datum=NAD83"))

# macierz wag według kryterium wspólnej granicy
cont.sp<-as(pow, "SpatialPolygons") #konwersja polygons do klasy sp
cont.nb<-poly2nb(cont.sp, queen=T) #konwersja sp do klasy nb

# utworzenie macierzy wag standaryzowanej wierszami do 1 (opcja W)
cont.listw<-nb2listw(cont.nb, style="W") 
cont.listw # wyświetla podsumowanie macierzy wag

# współrzędne środków powiatów
crds.pow<-coordinates(pow)
colnames(crds.pow)<-c("cx", "cy")

plot(pow) # mapa konturowa Rys.4.2
plot(cont.nb, crds.pow, add=TRUE) # warstwa sąsiedzka

# konwersja do klasy matrix
cont.mat<-nb2mat(cont.nb)
cont.mat[1:5, 1:5]

woj<-readOGR(".", "wojewodztwa") # 16 jedn. 
woj<-spTransform(woj, CRS("+proj=longlat +datum=NAD83"))
nazwy_woj<-as.character(woj$jpt_nazwa_) # wektor nazw regionów
nazwy_woj

cont.woj.nb<-poly2nb(as(woj, "SpatialPolygons"), row.names=nazwy_woj)
cont.woj.mat<-nb2mat(cont.woj.nb) # konwersja do klasy matrix
cont.woj.mat[1:5, 1:5]
nazwy_woj[cont.woj.nb[[which(nazwy_woj=="lubuskie")]]]

#4.2.4 Macierz k najbliższych sąsiadów (k nearest neighbours, knn)

crds.woj<-coordinates(woj) # centroidy województw NTS2
head(crds.woj)

# macierz k=5 najbliższych sąsiadów dla danych obszarowych
woj.knn<-knearneigh(crds.woj, k=5) # powstaje obiekt klasy knn
woj.knn.nb<- knn2nb(woj.knn) 

# Rys.4.3a – powiązania k najbliższych sąsiadów
plot(woj, main="K najbliższych sasiadow, k=5")	# kontur regionalny
plot(woj.knn.nb, crds.woj, add=TRUE) #warstwa powiązań

# sprawdzanie symetryczności macierzy
print(is.symmetric.nb(woj.knn.nb))
woj.knn.sym.nb<-make.sym.nb(woj.knn.nb)
print(is.symmetric.nb(woj.knn.sym.nb))

# tworzenie obiektu klasy listw 
woj.knn.sym.listw<-nb2listw(woj.knn.sym.nb)

library(dplyr)
firmy<-read.csv("geoloc data.csv", header=TRUE, dec=",", sep=";") 
firmy.sub<-sample_n(as_tibble(firmy), size=100, replace=FALSE)
names(firmy.sub)
class(firmy.sub)

# macierz k=5 najbliższych sąsiadów dla danych punktowych
firmy.knn<-knearneigh(as.matrix(firmy.sub[,12:13]), k=5) #obiekt klasy knn
firmy.knn.nb<- knn2nb(firmy.knn) 

# Rys.4.3b – powiązania k najbliższych sąsiadów
plot(woj[woj$jpt_nazwa_=="lubelskie",]) # rysowanie wycinka mapy
plot(firmy.knn.nb, as.matrix(firmy.sub[,12:13]), add=TRUE) #warstwa powiązań

print(is.symmetric.nb(firmy.knn.nb))
firmy.knn.sym.nb<-make.sym.nb(firmy.knn.nb)
print(is.symmetric.nb(firmy.knn.sym.nb))

# tworzenie obiektu klasy listw 
firmy.knn.sym.listw<-nb2listw(firmy.knn.sym.nb)
summary(firmy.knn.sym.listw)

#4.2.5	Macierz oparta o kryterium odległości (sąsiadów w promieniu d km)

# Rys.4.4a - macierz sąsiadów w promieniu d km
conti.d.30<-dnearneigh(crds.pow, 0, 30, longlat=TRUE)
plot(pow) # mapa podkładowa
plot(conti.d.30, crds.pow, add=TRUE) # relacje sąsiedzkie

# konwersja nb do matrix
conti.d.30.m<-nb2mat(conti.d.30, zero.policy=TRUE)
a<-colMeans(t(conti.d.30.m)) # średnie w wierszach
pow$a<-a # dopisanie wektora wartości do shapefile
spplot(pow, "a") # Rys.4.4b

conti.d.30.listw<-nb2listw(conti.d.30)
#Błąd w poleceniu 'nb2listw(conti.d.30)':Empty neighbour sets found

# macierz sąsiadów w promieniu d km, aby każdy region miał sąsiada
kkk<-knn2nb(knearneigh(crds.pow))
wszyscy<-max(unlist(nbdists(kkk, crds.pow)))
wszyscy.nb<-dnearneigh(crds.pow, 0, wszyscy)
summary(wszyscy.nb, crds.pow)

plot(pow, border="grey") # Rys.4.5
plot(wszyscy.nb, coords.pow, add=TRUE)

#4.2.6 Macierz odwrotnej odległości

# macierz odwrotnej odległości
powiaty.knn<-knearneigh(crds.pow, k=379) 
powiaty.nb<-knn2nb(powiaty.knn)
dist<-nbdists(powiaty.nb, crds.pow) 
dist1<-lapply(dist, function(x) 1/x) # obiekt klasy list
powiaty.dist.listw<-nb2listw(powiaty.nb, glist=dist1)
summary(powiaty.dist.listw)	

#macierz potęgowa
dist2<-lapply(dist, function(x) x**(-2)) 
powiaty.dist.listw2<-nb2listw(powiaty.nb, glist=dist2)

#macierz wykładnicza
dist3<-lapply(dist, function(x) exp(-1.5*x)) 
powiaty.dist.listw3<-nb2listw(powiaty.nb, glist=dist3)

#4.2.7	Podsumowania i edycja macierzy wag 

summary(conti.d.30) #podsumowanie macierzy sąsiedztwa klasy nb
wszyscy.listw<-nb2listw(wszyscy.nb) 
summary(unlist(wszyscy.listw$weights))
wszyscy.mat<-nb2mat(wszyscy.nb)
summary(wszyscy.mat)
table(card(wszyscy.nb))
woj.knn.mat<-nb2mat(woj.knn.nb)
print(woj.knn.mat)
cont.listw$weights

# uruchomienie interfejsu edycji
edit.nb(woj.knn.nb, crds.woj, polys=woj) # rys.4.6
cont.woj.nb
logic<-c(F,F,F,T,F,F,F,F,F,F,F,F,F,F,F,F)
nazwa<-c("mazowieckie")
id<-c(4)

zmiana1<-droplinks(cont.woj.nb, logic)
zmiana2<-droplinks(cont.woj.nb, nazwa)
zmiana3<-droplinks(cont.woj.nb, id)	
zmiana1 	#pozostałe dają identyczne rezultaty

subset<-c(F,T,F,T,F,F,F,F,F,F,T,F,F,F,F,F)
subset.woj<-subset.nb(cont.woj.nb, subset)
subset.woj

cont.woj.nb.self<-include.self(cont.woj.nb)
cont.woj.nb.self

par(mfrow=c(1,3)) # okno w podziale 1 x 3
par(mar=c(5.1, 2, 4.1, 1))

plot(woj, main="complement.nb()")
plot(complement.nb(zmiana1), crds.woj, add=T)

plot(woj, main="intersect.nb()")
plot(intersect.nb(cont.woj.nb, zmiana1), crds.woj, add=T)

plot(woj, main="setdiff.nb()")
plot(setdiff.nb(cont.woj.nb, zmiana1), crds.woj, add=T)

par(mfrow=c(1,1)) # okno w podziale 1 x 1

#4.2.7	Opóźnienia przestrzenne i sąsiedztwo wyższego rzędu

head(levels(pow$jpt_nazwa_))

pow$SZOK<-rep(0,380)
pow$SZOK[pow$jpt_nazwa_=="powiat Łódź"]<-1 	#Łódź
pow$SZOK[pow$jpt_nazwa_=="powiat Warszawa"]<-1 	#Warszawa
pow$SZOK[pow$jpt_nazwa_=="powiat Gdańsk"]<-1 	#Gdańsk
pow$SZOK[pow$jpt_nazwa_=="powiat Poznań"]<-1 	#Poznań
spplot(pow, "SZOK") 					# centra szoków Rys.4.7a

# opóźnienie przestrzenne zmiennej SZOK – pierwszy rząd
pow$lagg<-lag.listw(cont.listw, pow$SZOK)
summary(pow$lagg)
spplot(pow, "lagg") 			#opóźnienie pierwszego rzędu

# opóźnienie przestrzenne zmiennej SZOK – drugi rząd
powiaty.2.list<-nblag(cont.nb, 2)
powiaty.2.nb<-nblag_cumul(powiaty.2.list)
pow$lagg<-lag.listw(nb2listw(powiaty.2.nb), pow$SZOK) # opóźnienie
spplot(pow, "lagg") 	# opóźnienie drugiego rzędu

# opóźnienie przestrzenne zmiennej SZOK – trzeci rząd
powiaty.3.list<-nblag(cont.nb, 3)
powiaty.3.nb<-nblag_cumul(powiaty.3.list)
pow$lagg<- lag.listw(nb2listw(powiaty.3.nb), pow$SZOK)
spplot(pow, "lagg") 	#Rys.4.8b - opóźnienie trzeciego rzędu

#4.2.8 Tworzenie macierzy wag w oparciu o przynależność grupową

dane<-read.csv("dane_pow_2019.csv", header=TRUE, dec=",", sep=";")
sub<-dane[dane$rok==2017,]
names(sub)
table(sub$wojew_nazwa)
matt<-matrix(0, nrow=380, ncol=380) #utworzenie pustej macierzy

nazwy<-levels(sub$wojew_nazwa)
nazwy

for(i in 1:16){
c1<-which(sub$wojew_nazwa==nazwy[i])
matt[c1, c1]<-1}
diag(matt)<-0

vec<-rowSums(matt) # sumy w wierszach – de facto liczba sąsiadów
matt.W<-matt/vec # standaryzacja macierzy
matt.listw<-mat2listw(matt.W) # konwersja do listw
matt.listw

# wizualizacja wartości w macierzy wag
a<-apply(matt.W, 1, max) 	# max w wierszach
library(GISTools)
choropleth(pow, a)		# wartość wag w powiecie
plot(woj, add=TRUE, lwd=2) 	# kontur wojewódzki

sub<-dane[dane$rok==2017, ]
names(sub)
sub.k<-sub[,c(21,32,11)]

library(factoextra)
library(RColorBrewer)
fviz_nbclust(sub.k, kmeans, method="silhouette") # Rys.4.10a
clus<-eclust(sub.k, "kmeans", hc_metric="euclidean",k=2, graph=FALSE)

brks<-c(0,1,2,3)
cols<-brewer.pal(3, "Purples")
plot(pow, col=cols[findInterval(clus$cluster, brks)]) # Rys.4.10b

matt<-matrix(0, nrow=380, ncol=380) #utworzenie pustej macierzy
for(i in 1:2){
c1<-which(clus$cluster==i)
matt[c1, c1]<-1}
diag(matt)<-0

vec<-rowSums(matt) # sumy w wierszach – de facto liczba sąsiadów
matt.W<-matt/vec # standaryzacja macierzy
matt.listw<-mat2listw(matt.W) # konwersja do listw
matt.listw

# wizualizacja wartości w macierzy wag
a<-apply(matt.W, 1, max) 	# max w wierszach
library(GISTools)
choropleth(pow, a)		# wartość wag w powiecie
plot(woj, add=TRUE, lwd=2) 	# kontur wojewódzki

#4.3 Pomiar odległości i agregacja przestrzenna

firmy<-read.csv("geoloc data.csv", header=TRUE, dec=",", sep=";")
crds.Lublin<-c(22.4236877, 51.2180254) # współrzędne Lublina

# współrzędne xy firm – obiekt klasy SpatialPoints
loc<-SpatialPoints(firmy[,12:13], proj4string=CRS("+proj=longlat +datum=NAD83"))
head(loc)

# wektor odległości wszystkich punktów od centrum - Lublina
odle<-spDistsN1(loc, crds.Lublin, longlat = TRUE)

# paleta kolorystyczna
library(wesanderson)
cols<-wes_palette(n=8, name="Darjeeling1", type="continuous")
cols	# kolory palety jako pionowe pasy

# mapa punktowa określająca kolorystycznie odległość punktu od centrum
summary(odle)

brks<-c(0, 2, 25, 50, 75, 100, 125, 150)
lubelskie.woj<- woj[woj$jpt_nazwa_=="lubelskie",] #tworzenie wycinka mapy
lubelskie.pow<-pow[50:73,] #tworzenie wycinka w obiekcie powiatowym
plot(lubelskie.woj)
plot(lubelskie.pow, add=TRUE)

points(firmy[,12:13], col=cols[findInterval(odle, brks)], 
pch=21, bg=cols[findInterval(odle, brks)], cex=0.2)

legend("bottomleft", legend=brks, pt.bg=cols, bty="n", pch=21)
title(main="Odległość punktów od centrum")
savePlot(filename="dists", type="jpg")

# sprawdzanie przynależności punktów do obszarów
lubelskie.pow<-pow[50:73,] #tworzenie wycinka w obiekcie powiatowym
loc<-SpatialPoints(firmy[,12:13], proj4string=CRS("+proj=longlat +datum=NAD83"))

# przpisanie punktów do obszarów (powiatów)
firmy.over<-over(loc, lubelskie.pow) # z pakietu sp
dim(firmy.over)

names(firmy.over) # ten sam wynik uzyska się z names(pow)
head(firmy.over$jpt_nazwa_)

takie.same<-zerodist(loc)
head(takie.same)

# losowanie nowych punktów w obszarze mapy i ich konwersja do klasy matrix
# losowanie pkt na mapie, opcje: random | regular | stratified |
# | nonaligned | hexagonal | clustered | Fibonacci

pl<-readOGR(".", "Panstwo") # mapa konturowa Polski bez podziału wewn. 
pl<-spTransform(pl, CRS("+proj=longlat +datum=NAD83"))

nowepunkty<-spsample(pl, 20000, type="stratified") 
nowepunkty.df<-as.data.frame(nowepunkty)		# konwersja klasy
nowepunkty.m<-as.matrix(nowepunkty.df)		# konwersja klasy

#sprawdzenie przynależności punktu do regionu i wybranie kluczowej zmiennej
gdzie<-over(nowepunkty, woj) 	
nowepunkty.df$woj<-gdzie$jpt_nazwa_ 	#zmienna o regionie

head(nowepunkty.df)
dim(nowepunkty.df)
regiony<-levels(nowepunkty.df$woj) 	# nazwy województw
regiony

# wczytanie danych powiatowych, które mają identyfikator centrów regionów
bezrob<-read.csv("bezr2018.csv", header=TRUE, dec=",", sep=";")

# dopisanie koordynat centrodiów do zbioru danych
bezrob$crds<-coordinates(pow) # dopisane jako matrix w data frame	

# wybór istotnych kolumn – nazwa województwa i współrzędne geograficzne
stolice.xy<-bezrob[bezrob$stolice_woj==1, c(6,102)] 

# korekta wielkości liter 
stolice.xy$województwo<-tolower(stolice.xy$województwo) 
stolice.xy<-stolice.xy[1:16,]

head(stolice.xy)

# łączenie zbiorów danych wg zmiennej-klucza
odle<-merge(nowepunkty.df, stolice.xy, by.x="woj", by.y="województwo", all.x=TRUE, sort=FALSE)
names(odle)
head(odle)

# liczenie odległości pomiędzy parami współrzędnych
library(raster)
for(i in 1:dim(odle)[1]){
odle$odle[i]<-pointDistance(odle[i,2:3],odle$crds[i,], lonlat=FALSE)}

head(odle)

# wykres wartości w punkcie
library(fields)
quilt.plot(odle[,2:3], odle$odle) # Rys.4.12a
	 
library(cluster)
library(factoextra)
library(wesanderson) 
library(GISTools)

# klastrowanie koordynat
c2<-clara(firmy[,12:13], 5, metric="euclidean", sampsize=1000)

# połączenie wyników klastrowania i sprawdzania przynależności
punkty<-cbind(firmy[,12:13], firmy.over$jpt_nazwa_, c2$clustering)
head(punkty)
names(punkty)<-c("xx", "yy", "powiat", "cluster")
head(punkty)

# podsumowanie przynależności punktów do powiatów wg klastrów z CLARA
# tj. w jakich powiatach są punkty z pierwszego klastra CLARA
unique(punkty$powiat[punkty$cluster==1]) 

# sprawdzenie ile punktów jest w ramach wieloboków (powiatów)
ile.pkt.w.pow<-poly.counts(loc, lubelskie.pow)# z pakietu GISTools
ile.pkt.w.pow

# gęstość pkt w odniesieniu do powierzchni – Rys.4.13b
choropleth(lubelskie.pow, ile.pkt.w.pow/poly.areas(lubelskie.pow))

NN<-1500 # liczba obserwacji
samm<-spsample(pow, n=NN, type="random") # próbka przestrzenna
val<-rnorm(NN, mean=100, sd=20) # wylosowane wartości
samm.df<-as.data.frame(samm)
samm.df$val<-val
head(samm.df)

brks<-c(40,60,80,100,120,140,160)
cols<-wes_palette(n=8, name="BottleRocket2", type="continuous")
plot(pow, border="grey80") #Rys.4.13a
points(samm.df[,1:2], pch=".", cex=5, col=cols[findInterval(samm.df[,3], brks)])

# sprawdzanie przynależności punktu do obszaru 
samm.over.pow<-over(samm, pow) # do powiatów
samm.over.woj<-over(samm, woj) # do województw
samm.df$pow<-samm.over.pow$jpt_nazwa_
samm.df$woj<-samm.over.woj$jpt_nazwa_

head(samm.df)

# agregowanie danych punktowych
wynik<-aggregate(samm.df$val, by=list(samm.df$woj), sum)
woj.df<-as.data.frame(woj)
woj.df$id<-1:16
woj.df<-woj.df[,c(6,30)]
woj.df.m<-merge(woj.df, wynik, by.x="jpt_nazwa_", by.y="Group.1")

# sortowanie danych zagregowanych
library(doBy)
wynik.sort<-orderBy(~id, data=woj.df.m)

# kolorowa mapa województw Rys.4.13b
library(RColorBrewer)
library(classInt)
zmienna<-wynik.sort$x
summary(zmienna)
przedziały<-8
kolory<-brewer.pal(przedziały, "BuPu") # wybór kolorów
klasy<-classIntervals(zmienna, przedziały, style="pretty")
tabela.kolorów<-findColours(klasy, kolory) 
plot(woj, col=tabela.kolorów)
legend("bottomleft", legend=names(attr(tabela.kolorów, 
"table")), fill=attr(tabela.kolorów, "palette"), cex=0.75, bty="n")
title(main="Sumy wg województw")

# najbliżsi sąsiedzi wygenerowanych punktów
samm.knn<-knearneigh(samm, k=2) # obiekt klasy knn k=2
samm.nb<-knn2nb(samm.knn) 
samm.listw<-nb2listw(samm.nb) # konwersja klasy nb na listw
samm.lag<-lag.listw(samm.listw, samm.df$val) # opóźnienie przestrzenne
dev.off()
plot(samm.df$val, samm.lag)

#4.4 Teselacja

library(spatstat)
library(rgdal)
library(maptools)

# opcja A – wczytanie mapy z koordynatami planarnymi
woj<-readOGR(".", "wojewodztwa") # 16 jedn.
lub.woj<- woj[woj$jpt_nazwa_=="lubelskie",] #tworzenie wycinka mapy
lub.owin<-as(lub.woj, "owin") #z pakietu rgdal::

# opcja B – konwersja projekcji ze sferycznych do planarnych
#woj<-readOGR(".", "wojewodztwa") # 16 jedn.
#woj<-spTransform(woj, CRS("+proj=longlat +datum=NAD83")) #sferyczne
woj<-spTransform(woj, CRS("+proj=merc +datum=NAD83")) # koordynaty planarne
lub.woj<- woj[woj$jpt_nazwa_=="lubelskie",] #tworzenie wycinka mapy
lub.owin<-as(lub.woj, "owin") #z pakietu rgdal::

#wydobycie unikalnych punktów i wylosowanie próbki
cord<-as.matrix(cbind(firmy$coords.x1, firmy$coords.x2))
cord1<-unique(cord)
x<-sample(1:length(cord1), 100)
x<-order(x)
cord2<-cord1[x,]

cord2.sp<-SpatialPoints(cord2) # punkty w klasie sp - sferyczne
proj4string(cord2.sp)<-CRS("+proj=longlat +datum=NAD83") # sferyczne
cord2.sp<-spTransform(cord2.sp, CRS("+proj=merc +datum=NAD83")) #planarne

#budowa obiektu przestrzennego i przeprowadzenie teselacji
lub.ppp<-ppp(x=cord2.sp@coords[,1], y=cord2.sp@coords[,2], window=lub.owin)
lub.tes<-dirichlet(lub.ppp) # Dirichlet tessellation
plot(lub.tes, main="Teselacja dla n=100 pkt") # Rys.4.15a
plot(lub.ppp, add=TRUE, pch=".", col="darkblue", cex=2)
degAxis(1)
degAxis(2)

tes.poly<-as(lub.tes, "SpatialPolygons") 
proj4string(tes.poly)<-CRS("+proj=merc +datum=NAD83") # sferyczne
tes.poly<-spTransform(tes.poly, CRS("+proj=longlat +datum=NAD83"))

library(tripack)
lub.vm <- voronoi.mosaic(cord2[,1], cord2[,2])
plot(lub.vm) # Rys.4.15b
woj<-readOGR(".", "wojewodztwa") # 16 jedn.
woj<-spTransform(woj, CRS("+proj=longlat +datum=NAD83")) #sferyczne
lub.woj<- woj[woj$jpt_nazwa_=="lubelskie",] #tworzenie wycinka mapy
plot(lub.woj, add=TRUE, lwd=2, border="red")

lub.vp <- voronoi.polygons(lub.vm)
head(lub.vp)

#4.5 Statystyki przestrzenne

# wczytanie danych powiatowych
bezrob<-read.csv("bezr2018.csv", header=TRUE, dec=",", sep=";")
names(bezrob)

# mapa powiatowa i macierz wag przestrzennych
pow<-readOGR(".", "powiaty") # 16 jedn. 
pow<-spTransform(pow, CRS("+proj=longlat +datum=NAD83"))

cont.nb<-poly2nb(as(pow, "SpatialPolygons")) 	# z pakietu spdep::
cont.listw<-nb2listw(cont.nb, style="W")		# z pakietu spdep::
  
#4.5.1 Statystyki globalne
#4.5.1.1 Statystyka globalna I Morana

moran(bezrob$X2011.06, cont.listw, length(cont.nb), Szero(cont.listw))
moran.test(bezrob$X2011.06, cont.listw)
m3<-moran.test(bezrob$X2011.06, cont.listw, randomisation=FALSE)
m3
# p-value dla I Morana (rozkład normalny)
pval.norm<-1-pnorm(m3$statistic, mean=0, sd=1)
pval.norm
moran.mc(bezrob$X2011.06, cont.listw, 99)

zmienna<-bezrob$X2011.06
zmienna.std<-((zmienna-mean(zmienna))/sd(zmienna))
moran.plot(zmienna.std, cont.listw, labels=as.character(bezrob$powiat), pch=19, quiet=F)

x<-bezrob$X2011.06 		# wyodrębnienie zmiennej
zx<-scale(x) 			#standaryzacja zmiennej
mean(zx) 				# kontrola średniej
sd(zx) 				# kontrola odchylenia std.
wzx<-lag.listw(cont.listw, zx) # opóźnienie przestrzenne zmiennej x
morlm<-lm(wzx~zx) 		# regresja   
slope<-morlm$coefficients[2] 	# współczynnik kierunkowy
intercept<-morlm$coefficients[1] # stała
par(pty="s") 			# kwadratowe okno wykresu
plot(zx, wzx, xlab="zx",ylab="opóźnienie przestrzenne zx", pch="*") 
abline(intercept, slope) 	# linia regresji
abline(h=0, lty=2) 		# linia pozioma w y=0
abline(v=0, lty=2) 		#linia pionowa w x=0

# mapa przynależności do ćwiartek wykresu punktowego Morana
# tworzenie zmiennej do analizy
x<-bezrob$X2011.06 # wyodrębnienie zmiennej ze zbioru
zx<-scale(x) #standaryzacja zmiennej
wzx<-lag.listw(cont.listw, zx) # opóźnienie przestrzenne zmiennej x

cond1<-ifelse(zx>=0 & wzx>=0, 1,0) # I cwiartka
cond2<-ifelse(zx>=0 & wzx<0, 2,0) # II cwiartka
cond3<-ifelse(zx<0 & wzx<0, 3,0) # III cwiartka
cond4<-ifelse(zx<0 & wzx>=0, 4,0) # IV cwiartka
cond.all<-as.data.frame(cond1+cond2+cond3+cond4) 

# wykres - mapa kolorystyczna
brks<-c(1,2,3,4)
cols<-c("grey25", "grey60", "grey85", "grey45")
par(mar=c(5.1,1,4.1,1))
plot(pow, col=cols[findInterval(cond.all$V1, brks)])

legend("bottomleft", legend=c("I ćw - HH - wysokie otoczone wysokimi", "II ćw - LH - niskie otoczone wysokimi", "III ćw - LL - niskie otoczone niskimi", "IV ćw - HL - wysokie otoczone niskimi"), fill=cols, bty="n", cex=0.8)

title(main="Przynależność regionów do ćwiartek 
 z wykresu punktowego Morana")

#4.5.1.2 Statystyka globalna C Geary’ego (Geary C) 


geary(bezrob$X2011.06, cont.listw, length(cont.nb), length(cont.nb)-1, Szero(cont.listw))
geary.test(spNamedVec("X2011.06", bezrob), cont.listw)
geary.mc(bezrob$X2011.06, cont.listw, 99)

#4.5.1.3 Statystyki join-count

summary(bezrob$X2011.06)

head(bezrob$X2011.06)

zmienna.f<-factor(cut(bezrob$X2011.06, breaks=c(0,10, 20, 40), labels=c("niskie", "średnie", "wysokie")))

head(zmienna.f)
#[1] wysokie średnie średnie średnie średnie średnie
#Levels: niskie średnie wysokie

# parametry grafiki
brks1<-c(0, 10, 20, 40) 
cols<-c("green", "blue", "red")

# wykres punktowy kolejnych wartości badanej zmiennej – Rys.4.18a
plot(bezrob$X2011.06, bg=cols[findInterval(bezrob$X2011.06, brks1)], pch=21)
abline(h=c(10,20,40), lty=3)

# przestrzenny rozkład wartości na trzy wyróżnione grupy – Rys.4.18b
plot(pow, col=cols[findInterval(bezrob$X2011.06, brks1)])
plot(woj, add=TRUE, lwd=2)
title(main="Bezrobocie w czerwcu 2011")
legend("bottomleft", legend=c("niskie", "średnie", "wysokie"), leglabs(brks1), fill=cols, bty="n")

joincount.test(zmienna.f, cont.listw)
joincount.mc(zmienna.f, cont.listw, 99)
joincount.multi(zmienna.f, cont.listw)

#4.5.2. Statystyki autokorelacji przestrzennej lokalnej
#4.5.2.1 Statystyka lokalna I Morana (Local Moran, LISA)

locM<-localmoran(spNamedVec("X2011.06", bezrob), cont.listw)
oid1<-order(bezrob$ID_MAPA)
printCoefmat(data.frame(locM[oid1,], row.names=bezrob$powiat[oid1]), check.names=FALSE)
 
#wektor zduplikowanych nazw
dupli<-c("Powiat tomaszowski", "Powiat krośnieński", "Powiat brzeski", "Powiat ostrowski", "Powiat opolski", "Powiat grodziski", "Powiat nowodworski", "Powiat bielski", "Powiat średzki", "Powiat świdnicki")

#zmiana typu danych z factor na character
bezrob$powiat<-as.character(bezrob$powiat)

#pętla dodająca apostrof do drugiego wystąpienia nazwy
for(i in 1: length(dupli)){
a<-which(bezrob$powiat==dupli[i])[2]
bezrob$powiat[a]
bezrob$powiat[a]<-paste0(as.character(bezrob$powiat[a]), "'")}

#przywrócenie pierwotnej klasy zmiennej
bezrob$powiat<-as.factor(bezrob$powiat)

# kod generujący listę lokalnych statystyk Morana z przypisaniem nazwy regionu
locM<-localmoran(spNamedVec("X2011.06", bezrob), cont.listw)
oid1<-order(bezrob$ID_MAPA)
locMorMat<-printCoefmat(data.frame(locM[oid1,], row.names=bezrob$powiat[oid1]), check.names=FALSE)

#drukowanie pierwszych sześciu istotnych wartości <0.05
head(locMorMat[locMorMat$Pr.z...0.<0.05,])

#drukowanie istotnych wartości >0.95
locMorMat[locMorMat$Pr.z...0.>0.95,]

# mapa istotności statystyk lokalnych Morana
names(locMorMat)[5]<-"Prob"
brks<-c(min(locMorMat[,5]), 0.05000, 0.95000, max(locMorMat[,5]))
cols<-c("grey30", "grey90", "grey60")

plot(pow, col=cols[findInterval(locMorMat[,5], brks)])
legend("bottomleft", legend=c("otoczony relatywnie wysokimi wartościami, locM>0", "nieistotne", "otoczony relatywnie niskimi wartościami, locM<0"), fill=cols, bty="n", cex=0.75)
title(main="statystyka Local Moran", cex=0.7)
plot(woj, add=TRUE, lwd=2)

#4.5.2.2 Statystyka lokalna C Geary’ego (Local Geary)
#4.5.2.3 Lokalna statystyka Gi (Getis-Ord G) 

# statystyka local Gi
locG<-localG(bezrob$X2011.06, cont.listw)
# locGstar<-localG(bezrob$X2011.06, nb2listw(include.self(cont.nb)))
summary(locG)

# test istotności t-studenta dla n=100 
sig<-ifelse(locG<=-3.289 | locG>=3.289, "*", " ")
which(sig=="*")
bezrob[which(sig=="*"), c(3,6,10,18)]
# wykres istotnych statystyk locG
brks<-c(-10,-3.289, 3.289, 10)
cols<-c("grey40", "grey85", "grey55")
cols<-c("red", "grey85", "green")
plot(pow, col=cols[findInterval(locG, brks)])
legend("bottomleft", legend=c("G istotna - otoczony relatywnie niskimi wartościami", "G nieistotna", "G istotna - otoczony relatywnie wysokimi wartościami") , fill=cols, bty="n", cex=0.75)
title(main="istotne statystyki G")

#4.5.2.4. Lokalna heteroskedastyczność przestrzenna (LOSH)
	
# statystyka local Gi
locG<-localG(bezrob$X2011.06, cont.listw)
a<-summary(locG)

# wykres statystyk Gi
brks<-c(a[1], a[2], a[3], a[5], a[6])
colfunc<-colorRampPalette(c("royalblue", "springgreen", "yellow", "red"))
coli<-colfunc(5)
plot(pow, col=coli[findInterval(locG, brks)], main="Statystyki Gi")
legend("bottomleft", legend=c("Bardzo niskie", "Niskie", "Średnie", "Wysokie", "Bardzo wysokie") , fill=coli, bty="n")

#local Hi LOSH
locH<-LOSH(bezrob$X2011.06, cont.listw, a=2, var_hi=TRUE, zero.policy=TRUE, na.action=na.exclude)
summary(locH)

b<-summary(locH[,"Hi"])
b

# wykres statystyk LOSH
brks<-c(b[1], b[2], b[3], b[5], b[6])
plot(pow, col=coli[findInterval(locH[,"Hi"], brks)])
legend("bottomleft", legend=c("Bardzo niskie", "Niskie", "Średnie", "Wysokie", "Bardzo wysokie") , fill=coli , bty="n")
title(main="Statystki Hi")

#4.6 Przestrzenne korelacje krzyżowe dla dwóch zmiennych 

library(spatialEco) # obliczenia, crossCorrelation()
library(GISTools) # grafika, choropleth()

cont.mat<-nb2mat(cont.nb) # macierz W konwertowana do klasy matrix

x1<-bezrob[,101]
x2<-bezrob[,100] # dane miesiąc do miesiąca

# wersja z macierzą w
ii<-crossCorrelation(x1, x2, w=cont.mat, type=c("LSCI", "GSCI"), k=99, scale.xy=FALSE, scale.partial=TRUE, scale.matrix=TRUE, alpha=0.05)
ii

# wersja z koordynatami i odległością
iii<-crossCorrelation(x1, x2, coords=crds.pow, type = c("LSCI", "GSCI"), k=99, dist.function="inv.power", scale.xy=FALSE, scale.partial=TRUE, scale.matrix=FALSE, alpha=0.05)
iii

cor(x1,x2) # korelacja Pearsona

head(iii$SCI[,"lsci.xy"]) # dostęp do wyniku

# mapowanie wyniku ii - rys.4.21a
choropleth(pow, ii$SCI[,"lsci.xy"])
odcienie<-auto.shading(ii$SCI[,"lsci.xy"])
choro.legend(14, 50.25, odcienie, cex=0.65, bty="n")
title(main="Macierz wspólnej granicy 
dane miesiąc do miesiąca")

# mapowanie wyniku iii – rys.4.21b
choropleth(pow, iii$SCI[,"lsci.xy"])
odcienie<-auto.shading(iii$SCI[,"lsci.xy"])
choro.legend(14, 50.25, odcienie, cex=0.65, bty="n")
title(main="Macierz odwrotnej kwadratowej odległości
dane miesiąc do miesiąca")

#4.7 Korelogram

# korelogram oparty na klasycznym współczynniku korelacji
corr.classic<-sp.correlogram(cont.nb, bezrob$X2018.05, order=6, method="corr")
print(corr.classic)

stat<-(dim(bezrob)[1]-2)^0.5*corr.classic$res/(1-corr.classic$res^2)^0.5
pvalue<-1-pnorm(abs(stat), mean=0, sd=1)
corr.classic.sig<-cbind(corr.classic$res, stat, pvalue)
options(scipen=999, digits=2)
corr.classic.sig

corr.moran<-sp.correlogram(cont.nb, bezrob$X2018.05, order=6, method="I")
print(corr.moran)

plot(corr.classic)
plot(corr.moran)

library(spatialEco)
bezrob$crds<-crds.pow # dodanie współrzędnych xy do zbioru danych
bezrob.lim<-bezrob[,c(102,101)] # data.frame koordynaty + 1 jedna zmienna
class(bezrob.lim)		# klasa data.frame
coordinates(bezrob.lim)<-bezrob.lim[,1] # określenie koordynat
class(bezrob.lim)		# już klasa SpatialPointsDataFrame

a<-correlogram(x=bezrob.lim, v=bezrob.lim@data[,'X2018.05'], dist=35, ns=99, latlong=TRUE, dmatrix=TRUE)

attributes(a)
